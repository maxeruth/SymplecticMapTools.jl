var documenterSearchIndex = {"docs":
[{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"EditURL = \"../../../birkhoff_averaging.jl\"","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/#Birkhoff-Averaging","page":"Birkhoff Averages","title":"Birkhoff Averaging","text":"","category":"section"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"This is an example of using the weighted Birkhoff averaging functions. Given a dynamical system F  mathbbR^d to mathbbR^d, an observation function h  mathbbR^d to mathbbR^n, and an initial point x_0 in mathbbR^d, the Birkhoff average is defined as","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"Bh(x_0) lim_Ttoinfty frac1Tsum_t = 0^T-1 (h circ F^t)(x_0)","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"It has been shown in a series of articles (see Sander and Meiss and the citations within, as well as Quantitative Periodicity for more detailed statements) that if hin C^infty and the trajectory starting at x_0 lies on a C^infty invariant circle or island chain, the Birkhoff average can be improved via weighting. Particularly, the formula is given by","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"WBh(x_0) = lim_Ttoinfty sum_t = 0^T-1 w_tT (h circ F^t)(x_0)","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"where w_tT is found by sampling a smooth windowing function alpha in C^infty with mathrmsupp(alpha) = 01 as","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"w_tT = frac1S alpha left(fractT+1right) qquad S = sum_t = 1^T alpha left(fractT+1right)","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"When this average is performed on a smooth integrable trajectory, the error is mathcalO(T^-M) for all M. Otherwise, in chaos, the error goes as mathcalO(T^-12).","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"In this document, we show how trajectories of the standard map can be classified via the convergence of a period-doubling adaptive version of this algorithm. Following Sander and Meiss, we consider the finite weighted Birkhoff average as","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"WB_Th(x_0) =  sum_t = 0^T-1 w_tT (h circ F^t)(x_0)","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"Then, we consider the algorithm to be converged if  WB_2T - WB_T   epsilon for some tolerance epsilon. This can be performed in mathcalO(T log T) time by taking the Birkhoff average after every doubling of T.","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"We will work with he standard map F  (x_t y_t) mapsto (x_t+1 y_t+1), given by","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"beginaligned\n    x_t+1 = x_t + y_t+1 mod 1 \n    y_t+1 = y_t - frack2pi sin(2pi x_t)\nendaligned","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"We will average over the quantity h(xy) = y. The average of this quantity gives the rotational transform of the invariant circle (NOTE: here we distinguish between rotational transform and rotation number, where rotational transform is defined as the twist around the torus and rotation number would be defined off of a ).","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"First, we show an example of calling the finite weighted Birkhoff average. By changing T, one can adjust the accuracy of the average. By changing x_0, one can choose between chaos and not chaos.","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"using Revise\nusing SymplecticMapTools\nusing CairoMakie\nusing Sobol","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"k_sm = 0.7;\nF = standard_map_F(k_sm);\n\nT = 100\nx0 = [0.4, 0.5]; # Invariant Circle\n# x0 = [0.49, 0.0]; # Chaos\n\n\nxs = zeros(2, T);\nxs[:, 1] = x0\nhs = zeros(T);\nhs[1] = x0[2];\nfor ii = 2:T\n    xs[:,ii] = F(xs[:,ii-1])\n    hs[ii] = xs[2, ii]\nend\n\n# Find the Average\nave = weighted_birkhoff_average(hs)\nprintln(\"The rotation number (Birkhoff average) is $(ave)\")\n\n# Plot the trajectory on the standard map\nf, xs_pp = poincare_plot([0,1], [0,1], F, 500, 1000, title=\"Standard Map, k = $(k_sm)\")\nax = contents(f[1, 1])\nplot!(xs[1,:], xs[2,:], color=:red, markersize=20)\n\nf","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"(Image: )","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"We see that the rotation number for the trajectory above is close to 05. This makes sense, because the island chain has two circles.","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"In order to show that the convergence is dependent on the initial orbit, we reproduce a figure from Sander and Meiss. Given a set of initial points on the standard map, we will plot WB_T vs T, showing the separation.","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"# Get averages at each $T$ in the sorted list of integers $T$\nfunction get_averages(F, h, x0, Ts)\n    NT = length(Ts); Tmax = maximum(Ts)\n    aves = zeros(NT); xs = zeros(2, Tmax); hs = zeros(Tmax)\n    xs[:,1] = x0; hs[1] = h(x0)\n\n    jj = 1\n    for t = 2:Tmax\n        xs[:, t] = F(xs[:, t-1]); hs[t] = h(xs[:,t])\n\n        if t == Ts[jj]\n            aves[jj] = weighted_birkhoff_average(hs[1:Ts[jj]]); jj = jj+1\n        end\n    end\n\n    return xs, aves\nend","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"get_averages (generic function with 1 method)","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"h = (x) -> x[2];\n\n# T values to use\nTmin = 100; Tmax = 50000; NT = 100;\nTs = Int.(floor.(LinRange(Tmin, Tmax, NT)))\nTs = vcat(Ts, Tmax*2) # This is the \"true\" value\n\n# Initial Points\nNy = 50; ys = LinRange(0, 0.5, Ny);\n\n# Create figure\nf = CairoMakie.Figure(resolution=(800,400));\nax1 = CairoMakie.Axis(f[1,1],  yscale=log10, xlabel=\"T\", ylabel=\"error\");\nax2 = CairoMakie.Axis(f[1,2], xlabel=\"x\", ylabel=\"y\");\n\n# Loop over trajectories\nfor (jj, y) in enumerate(ys)\n    xs, aves = get_averages(F, h, [0.45, y], Ts)\n    errs = abs.(aves[1:end-1] .- aves[end])\n\n    color = errs[end] < 1e-10 ? :blue : :black\n    label = errs[end] < 1e-10 ? \"\\\"Nice\\\"\" : \"Chaos\"\n    CairoMakie.lines!(ax1, Ts[1:end-1], errs[:] .+ 1e-16; color);\n    CairoMakie.scatter!(ax2, xs[1, :], xs[2, :]; color, markersize=2, label);\nend\nCairoMakie.scatter!(ax2, ones(Ny).*0.45, ys; color=:red, markersize=6, label=\"InitialPoints\")\naxislegend(ax2, merge=true)\n\ndisplay(f);","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"┌ Warning: Assignment to `xs` in soft scope is ambiguous because a global variable by the same name exists: `xs` will be treated as a new local. Disambiguate by using `local xs` to suppress this warning or `global xs` to assign to the existing global variable.\n└ @ /mnt/c/Users/mer335/Documents/GitHub/SymplecticMapTools.jl/docs/src/examples/birkhoff_averaging/birkhoff_averaging.md:18\n","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"We see that we successfully distinguish between \"nice\" trajectories like invariant circles and islands and chaotic ones. We can then use this with the adaptive average to categorize trajectories.","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"# Create a figure that categorizes trajectories as chaotic or not-chaotic.\ns = SobolSeq([0,0],[1,1]);\nN_init = 250;\nT_init = 250; T_max = (2^7)*T_init\nprintln(\"T_max = $(T_max)\")\n\nf = Figure(resolution=(800,800))\nax = Axis(f[1,1], xlabel=\"x\", ylabel=\"y\");\nfor ii = 1:N_init\n    ave, xs, hs, conv_flag = doubling_birkhoff_average(h, F, next!(s); T_init, T_max)\n\n    color = conv_flag ? :blue      : :black\n    label = conv_flag ? \"\\\"Nice\\\"\" : \"Chaos\"\n    CairoMakie.scatter!(ax, xs[1, :], xs[2, :]; color, markersize=2, label);\nend\naxislegend(ax, merge=true)\n\nf","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"(Image: )","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"","category":"page"},{"location":"examples/birkhoff_averaging/birkhoff_averaging/","page":"Birkhoff Averages","title":"Birkhoff Averages","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"EditURL = \"../../../kernel.jl\"","category":"page"},{"location":"examples/kernel/kernel/#Kernel-Method-for-Finding-Invariant-Circles","page":"Approximately Invariant Kernel Functions","title":"Kernel Method for Finding Invariant Circles","text":"","category":"section"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"Here, we will show examples of the kernel_eigs and kernel_bvp functions, which find approximately invariant functions of a symplectic map. To be more specific, let F  Omega to Omega be a symplectic map. An approximately invariant function h is one that satisfies","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"lVert hcirc F - h rVert ll lVert h rVert","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"for some norm. We find the function h by discretizing it via kernels, i.e. for a positive (semi)definite kernel K  Omega times Omega to mathbbR, we define the kernel function on the data y_n in Omega as","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"h(x) = sum_n = 1^2Nc_n K(x y_n)","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"For the points y_n, we first sample a sequence x_1 x_2 dots x_N in some domain U in Omega. Then, we evaluate F(x_n), giving the sequence y_1 = x_1, y_2 = F(x_1), y_3 = x_2, y_4 = F(x_2), etc.","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"SymplecticMapTools comes equipped with sampling schemes for rectangular domains. Consider the symplectic map:","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"using SymplecticMapTools\nusing CairoMakie\nusing LinearAlgebra","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"k_sm = 0.3;\nF = standard_map_F(k_sm);\n\nN = 500\nxb = [0., 1.]\nyb = [0., 1.]\nxs = kernel_sample_F(F, N, xb, yb);\nylims = yb\nf, xs_pp = SymplecticMapTools.poincare_plot([0,1], [0,1], F, N, 500; ylims, resolution=(600, 600),\n                         title=\"Standard Map, k = $(k_sm)\")\nax = contents(f[1, 1])\nplot!(xs[1,1:2:end], xs[2,1:2:end], color=:black, markersize=7, label=L\"x_n\")\nplot!(xs[1,2:2:end], xs[2,2:2:end], color=:blue, markersize=7, label=L\"F(x_n)\")\naxislegend()\n\nf","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"(Image: )","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"Above is a Poincare plot of the standard map with k = 03, along with the points y_n used for the kernel method. Now, to apply the method, we also need weights for boundary conditions w_mathrmbdOmega to mathbbR. The boundary condition weight function should be equal to 1 where you want to enforce boundary conditions, and 0 where you do not. It is typically best for it to be chosen smooth in between as well. One good option for this is to use a sum of logistic functions. A simple version of this is implemented in window_weight for maps in mathbbT times mathbbR and rectangular_window_weight for maps in mathbbR^2:","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"lims = [0.01, 0.99]; # window size, includes the boundaries\nα = 0.002;           # Transition length scale\nw = window_weight(xs, lims, α)\n\nresolution = (700, 400); fontsize=25;\nf = Figure(;resolution, fontsize)\nax = Axis(f[1,1], xlabel=L\"x_2\", ylabel=L\"w\")\nplot!(xs[2, :], w)\n\nf","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"(Image: )","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"The above plot shows how the weighting applys to the vertical component. We see we are applying our boundary conditions at the top and bottom, but not in the interior. Now, we have enough information to call kernel_eigs to find an approximately invariant function. It does this by minimizing the following Rayleigh quotient:","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"lambda = min_c frac E_mathrmInv + E_mathrmbd + E_mathrmK E_L^2","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"where","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"E_mathrmInv = sum_n = 1^N (h(y_2n-1) - h(y_2n))^2 = sum_n = 1^N (h(x_n) - h(F(x_n)))^2","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"is an energy that forces h to be approximately invariant,","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"E_mathrmbd = sum_n=1^2N w_mathrmbd(y_n) h(y_n)^2","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"is the a penalty on nonzero boundary conditions,","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"E_mathrmK = sum_n m = 1^2N K(y_n y_m) c_n c_m","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"is a kernel norm encouraging smooth solutions, and","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"E_L^2 = sum_n = 1^2N h(y_n)^2","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"is the L^2 norm of the function. We note that the eigenvalue problem is useful to get a nonzero solution (simply minimizing the numerator would give h = 0 regardless of the map, a decidedly unhelpful function).","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"We can see an output approximately invariant function in the following block:","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"ϵ = 1e-8 # Weight of regularization. Should be small and nonzero\nnev = 1  # Number of eigenvalues/eigenvectors to find\nσ = 0.25 # Length scale of the kernel\nkernel = :FourierSE # Product kernel that is periodic sine squared exponential in x and squared exponential in y\n\nλs, vs, k = kernel_eigs(xs, ϵ, nev, σ, w; kernel)\nprintln(\"The returned eigenvalue is λ = $(λs[1])\")\nf, f_grid = plot_on_grid(0:0.01:1, 0:0.01:1, k; levels=30,\n                         resolution=(700, 600), xlabel=\"x\", ylabel=\"y\",\n                         title=\"Approximately Invariant Eigenfunction\")\nf","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"(Image: )","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"Qualitatively, we see the contours of the label function matches the Poincare plot well. Additionally, the value of lambda tells us that E_mathrmInv ll E_L^2, which is the discretization of our definition of an approximately invariant function.","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"We can find such a plot without an eigenvalue solve as well using a boundary value problem. For this, we require a boundary value function h_mathrmbd  Omega to mathbbR. Given this, the boundary value problem is phrased as","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"R = min_c (E_mathrmInv + E_mathrmbdh + epsilon E_mathrmK)","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"where","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"E_mathrmbd h = sum_n=1^2N w_mathrmbd(y_n) (h(y_n) - h_mathrmbd(y_n))^2","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"is the new boundary condition energy. The boundary values give a different method by which the label function is forced to be nonzero. Typically, the boundary value problem is useful when you want to know if circles foliate a certain annulus.","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"We can apply this method using the function kernel_bvp:","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"hbd = [xi[2] > 0.5 ? 1. : -1. for xi = eachcol(xs)]\nk, R, E_bd, E_inv, E_K = kernel_bvp(xs, ϵ, σ, w, hbd; kernel)\nhs = evaluate(k, xs)\nprintln(\"R     = $R,\nE_bd  = $(E_bd),\nE_inv = $(E_inv),\nE_K   = $(E_K),\nE_L2  = $(hs'*hs)\")\nf, f_grid = plot_on_grid(0:0.01:1, 0:0.01:1, k; levels=30,\n                         resolution=(700, 600), xlabel=\"x\", ylabel=\"y\",\n                         title=\"Approximately Invariant BVP\")\nf","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"(Image: )","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"Again, we see a very similar invariant function, with E_mathrmInv ll E_L^2.","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"","category":"page"},{"location":"examples/kernel/kernel/","page":"Approximately Invariant Kernel Functions","title":"Approximately Invariant Kernel Functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#SymplecticMapTools.jl","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"","category":"section"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"This is a package devoted to different tools for analyzing (primarily 2D) symplectic maps. The overall goal of this package is to provide a set of tools that can be used to robustly characterize orbits and find invariant structures while being efficient in the number of evaluations of the map. If you have any algorithms that you would like to see added, pull requests are welcome!","category":"page"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"The implemented algorithms in this package include","category":"page"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"The Birkhoff extrapolation method for finding invariant circles [1]\nThe reproducing kernel Hilbert space based invariant level-set finding method [2]\nThe implementations of the parameterization method for finding invariant circles and connecting orbits (see, e.g., [3] for an introduction to the parameterization method)\nNewton's method with line search and BFGS for finding periodic orbits","category":"page"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"Examples of how to use the code are found in examples/. These examples are created using Literate.jl out of files found in docs/, and can be recreated locally by running docs/literate_examples.jl. Additionally, these notebooks are outputted to markdown and included in the documentation.","category":"page"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"[1] In preparation.\n[2] In preparation.\n[3] A. Haro, M. Canadell, J.-L. Figueras, A. Luque, and J. M. Mondelo, The Parameterization Method for Invariant Manifolds: From Rigorous Results to Effective Computations, vol. 195 of Applied Mathematical Sciences, Springer International Publishing, Cham, 2016.","category":"page"},{"location":"#Installation","page":"SymplecticMapTools.jl","title":"Installation","text":"","category":"section"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"For installation, add the package using the command ]add SymplecticMapTools in the Julia REPL. This package uses Requires for plotting. You must load CairoMakie or Plots separately to use the plotting functionality.","category":"page"},{"location":"#Development","page":"SymplecticMapTools.jl","title":"Development","text":"","category":"section"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"This is a new package, and things are changing rapidly! Currently, features involving the InvariantCircle struct, the extrapolation algorithm, and periodic orbits (1, 3, and 4 above) are mostly tested, with the features related to (3) still in need of testing. More examples are being added as well.","category":"page"},{"location":"#Examples","page":"SymplecticMapTools.jl","title":"Examples","text":"","category":"section"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"Pages = [\n   \"examples/birkhoff_averaging/birkhoff_averaging.md\"\n   \"examples/extrapolation/extrapolation.md\"\n   \"examples/kernel/kernel.md\"\n]","category":"page"},{"location":"#Documentation","page":"SymplecticMapTools.jl","title":"Documentation","text":"","category":"section"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"Pages = [\n  \"lib/Documentation.md\"\n]","category":"page"},{"location":"#Contact","page":"SymplecticMapTools.jl","title":"Contact","text":"","category":"section"},{"location":"","page":"SymplecticMapTools.jl","title":"SymplecticMapTools.jl","text":"For any questions, email mer335@cornell.edu","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"EditURL = \"../../../extrapolation.jl\"","category":"page"},{"location":"examples/extrapolation/extrapolation/#Extrapolation-Example","page":"Birkhoff Extrapolation","title":"Extrapolation Example","text":"","category":"section"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"This is an example of SymplecticMapTools.jl. The example exists both as a webpage and as a notebook. To find the notebook, simply go to the /examples/ folder in the package directory.","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"We will show how sequence extrapolation can be used for finding invariant circles of the Chirikov standard map. The standard map is given by","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"beginaligned\n    x_t+1 = x_t + y_t+1 mod 1 \n    y_t+1 = y_t - frack2pi sin(2pi x_t)\nendaligned","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"For this example, we will use k=07, which gives a nice mix of chaos, invariant circles, and islands.","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"using Revise\nusing SymplecticMapTools\nusing CairoMakie\nusing LinearAlgebra","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"k_sm = 0.7\nF = standard_map_F(k_sm)\n\nf, xs_pp = poincare_plot([0,1], [0,1], F, 500, 1000, title=\"Standard Map, k = $(k_sm)\")\nf","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"(Image: )","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"The extrapolation method presented here has two steps:","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"Perform an extrapolation method (minimal polynomial extrapolation (MPE) or reduced rank extrapolation (RRE)). The extrapolation method returns a filter for the sequence. When the linear model is applied to the sequence, it can extract the mean (also known as the Birkhoff ergodic average). Additionally, if the extrapolation returns a low residual, this can be used as an indicator that the trajectory is integrable (i.e. it is an invariant circle or island) rather than chaotic.\nIf the trajectory is classified as integrable, we can extract frequency information from the learned filter. This can be used to recover the rotation number, as well as the Fourier modes of the invariant structures.","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"As first step, we choose some initial points. The above plot was made using initial points sampled from a SoboloSeq (see Sobol.jl). So, we will simply use those:","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"Ncircle = 100\n\nresolution=(800, 800)\nfontsize=25\n\nx_init = xs_pp[:, 1, 1:Ncircle];\n\nf = Figure(resolution=(800, 800), fontsize=25);\nax = Axis(f[1,1], xlabel = \"x\", ylabel = \"y\", title = \"Initial points\");\nscatter!(x_init)\nf","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"(Image: )","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"Then, we find extrapolated models at each of these points. The model will be obtained via the adaptive_birkhoff_extrapolation function.","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"However, we note that there is a detail that must be considered with the standard map. The extrapolation code is written for continuous signals. The standard map is continuous on mathbbT times mathbbR, but it is not on mathbbR^2. The algorithms assume that the signal is continuous in mathbbR^2, however, so we need to map the space to an appropriate one. For this, we will use the observable function","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"h(x, y) = \\begin{pmatrix}\n\\left(y + \\frac{1}{2} \\right)\\cos(2\\pi x) \\\\\n\\left(y + \\frac{1}{2} \\right)\\sin(2\\pi x)\n\\end{pmatrix}","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"rtol = 1e-8\nKinit = 50\nKstride = 50\nKmax = 400\nNfactor = 1.5;\n\nh, HJ, hinv, HJinv = polar_map();\ncs = Vector{Vector{Float64}}(undef, Ncircle);\nhs = Vector{Matrix{Float64}}(undef, Ncircle);\nxs = Vector{Matrix{Float64}}(undef, Ncircle);\nrnorms = zeros(Ncircle)\nKs = zeros(Int64, Ncircle)\nfor ii = 1:Ncircle\n    if (ii % 10) == 0; println(\"ii = $(ii)/$(Ncircle)\"); end\n    cs[ii], _, _, xs[ii], hs[ii], rnorms[ii], Ks[ii], _ = adaptive_birkhoff_extrapolation(h, F, x_init[:, ii]; rtol, Kinit, Kstride, Kmax, Nfactor)\nend","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"ii = 10/100\nii = 20/100\nii = 30/100\nii = 40/100\nii = 50/100\nii = 60/100\nii = 70/100\nii = 80/100\nii = 90/100\nii = 100/100\n","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"markersize=5\nf = Figure(;resolution, fontsize);\nax = Axis(f[1,1], xlabel=\"x\", ylabel=\"y\");\nxlims!(0, 1); ylims!(0,1)\nfor ii = (1:Ncircle)\n    if rnorms[ii] < rtol\n        CairoMakie.scatter!(xs[ii][1,:], xs[ii][2,:]; color=:black, markersize, label=\"Invariant Circles / Islands\")\n    else\n        CairoMakie.scatter!(xs[ii][1,:], xs[ii][2,:]; color=:red, markersize, label=\"Chaos\")\n    end\nend\naxislegend(ax, merge=true)\nf","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"(Image: )","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"The above is a plot which shows the trajectories as black if the extrapolation algorithm converged to the tolerance of 1e-7 and red if they did not. We see that the red trajectories did not converge quickly, and they correlate strongly with whether the trajectory is in chaos. We can check the filter length for the values of K we iterated over:","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"for Ki = Kinit:Kstride:Kmax\n    Ksum = sum(Ks .== Ki)\n    println(\"Number of trajectories for K=$(Ki) is $(Ksum)\")\nend","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"Number of trajectories for K=50 is 37\nNumber of trajectories for K=100 is 21\nNumber of trajectories for K=150 is 8\nNumber of trajectories for K=200 is 6\nNumber of trajectories for K=250 is 1\nNumber of trajectories for K=300 is 5\nNumber of trajectories for K=350 is 1\nNumber of trajectories for K=400 is 21\n","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"We see that most trajectories are classified when K leq 200, with only a few being classified later. Additionally, those that are mis-classified tend to be at the edges of island chains or chaos.","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"Now, we turn to finding models for the invariant circles. We do this via the function get_circle_info.","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"zs = Vector{FourierCircle}(undef, Ncircle)\nfor ii = (1:Ncircle)[rnorms .< rtol]\n    zs[ii] = get_circle_info(hs[ii], cs[ii])\nend","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"Additionally, for the special case where we need to work with observations from h  mathbbTtimesmathbbR to mathbbR^2, we have a plotting routine that can be used to plot the invariant circles in mathbbR^2 given an inverse function h^-1. This is done in the following:","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"f = Figure(;resolution, fontsize);\nax = Axis(f[1,1], xlabel=\"x\", ylabel=\"y\")\nxlims!(0, 1); ylims!(0,1)\nfor ii = (1:Ncircle)[rnorms .< rtol]\n    lines_periodic!(ax, zs[ii], hinv; N=500, color=:red, linewidth=4, label=\"Invariant Circles\")\n    scatter!(xs[ii][1,:], xs[ii][2,:], markersize=3, color=:blue, label=\"Trajectories\")\nend\naxislegend(ax, merge=true)\nf","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"(Image: )","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"In the above plot, we have plotted the trajectories on the found invariant circles. We see that the trajectories qualitatively match well. Additionally, we can use the function get_circle_residual to find a validation error. This is useful in automatically identifying cases where the found Fourier series is incorrect.","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"N_norm = 6;\nerrs_validation = zeros(Ncircle)\nfor ii = (1:Ncircle)[rnorms .< rtol]\n    res = get_circle_residual((x) -> h(F(hinv(x))), zs[ii], N_norm)\n    errs_validation[ii] = norm(res)/sqrt(length(res))\nend\nind = rnorms .< rtol\n\nprintln(\"Invariant circle validation errors:\n   smallest --- $(minimum(errs_validation[ind]))\n   largest  --- $(maximum(errs_validation[ind]))\n   median   --- $(sort!(errs_validation[ind])[sum(ind)÷2])\n\")","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"Invariant circle validation errors:\n   smallest --- 2.0211746724319608e-15\n   largest  --- 1.634572910924854e-5\n   median   --- 4.225798236619171e-9\n\n","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"","category":"page"},{"location":"examples/extrapolation/extrapolation/","page":"Birkhoff Extrapolation","title":"Birkhoff Extrapolation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/Documentation/#Documentation","page":"Documentation","title":"Documentation","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"Documentation for SymplecticMapTools.jl","category":"page"},{"location":"lib/Documentation/#Contents","page":"Documentation","title":"Contents","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"Pages = [\n  \"Documentation.md\"\n]","category":"page"},{"location":"lib/Documentation/#Index","page":"Documentation","title":"Index","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"Pages = [\n  \"Documentation.md\"\n]","category":"page"},{"location":"lib/Documentation/#Periodic-Orbits","page":"Documentation","title":"Periodic Orbits","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"BFGS_periodic(::Function, ::AbstractVector, ::Integer)\nnewton_periodic(::Function, ::AbstractVector, ::Integer)","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.BFGS_periodic-Tuple{Function, AbstractVector, Integer}","page":"Documentation","title":"SymplecticMapTools.BFGS_periodic","text":"BFGS_periodic(FJ::Function, x::AbstractVector, q::Integer;\n              maxiter::Integer=50)\n\nFind a periodic orbit using BFGS from the Optim package.\n\nArguments:\n\nFJ: A function that returns the map and its derivative F, dFdx = FJ(x)\nx: An initial point to find the orbit from\nq: The period of the orbit\nmaxiter=50: The maximum number of optimization steps allows\n\nOutput:\n\nxs: A periodic trajectory of length d\nres: An Optim return object, (can check convergence with Optim.converged(res))\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.newton_periodic-Tuple{Function, AbstractVector, Integer}","page":"Documentation","title":"SymplecticMapTools.newton_periodic","text":"newton_periodic(FJ::Function, x::AbstractVector, q::Integer;\n                maxiter::Integer=50, rtol::Number=1e-8, verbose::Bool=false)\n\nFind a periodic orbit using Newton's method with line search\n\nArguments:\n\nFJ: A function that returns the map and its derivative F, dFdx = FJ(x)\nx: An initial point to find the orbit from\nq: The period of the orbit\nmaxiter=50: The maximum number of optimization steps allows\nrtol=1e-8: The residual tolerance required\nverbose=false: If true, outputs information about convergence\n\nOutput:\n\nxs: A periodic trajectory of length d\nconverged: A flag that indicates whether the orbit converged in maxiter steps\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#Invariant-Circles","page":"Documentation","title":"Invariant Circles","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"InvariantCircle\nevaluate(::InvariantCircle, ::Number)\ndeval(::InvariantCircle, ::Number)\nshifted_eval\nget_circle_residual\ngn_circle","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.InvariantCircle","page":"Documentation","title":"SymplecticMapTools.InvariantCircle","text":"abstract type InvariantCircle\n\nAn abstract type representing a chain of invariant circles zᵢ where zᵢ₊₁ = F(zᵢ) for i<=p and z₀ = F(zₚ₋₁). The main implementation of this type of FourierCircle, but other potential implementations of circles could exist.\n\nImplementations should have the following functions for immediate portability:\n\nBasic stuff\n\nInitializer   InvariantCircleImplementation(stuff)\nSimilar   Base.similar(z::InvariantCircle)\n\nGetters and Setters\n - Get number of unknown variables per circle     get_N(z::InvariantCircle)\n - Get period of circle     get_p(z::InvariantCircle)\n\nGet parameters (except τ)  get_a(z::InvariantCircle)\nSet parameters (except τ)  set_a!(z::InvariantCircle, a::AbstractArray)\nGet rotation number τ in [0,2π)  get_τ(z::InvariantCircle)\nSet τ  set_τ!(z::InvariantCircle, τ::Number)\n\nEvaluation related routines\n\nEvaluate the circle (see (z::InvariantCircle)(θ, i_circle))   evaluate(z::InvariantCircle, θ::AbstractVector; i_circle::Integer=1)\nEvaluate the derivative of the circle w.r.t. θ   deval(z::InvariantCircle, θ::AbstractVector; i_circle::Integer=1)\nGet a basis Φ for z evaluated at Nθ equispaced points (requires linearity)   get_Φ(z::InvariantCircle, Nθ::Integer; τ::Number=0.0)\nEvaluate the invariant circle on Φ   function grid_eval!(x::AbstractArray, z::InvariantCircle, Φ::AbstractArray;                       i_circle=0)\nEvaluate the derivative of the invariant circle on Φ   grid_deval!(dx::AbstractArray, z::InvariantCircle, Φ::AbstractArray;               i_circle=0)\n\nConstraints (for Newton iteration)\n\nConstrain the value at 0   fixed_θ0_constraint(z::InvariantCircle)\n\nOther routines (useful for continuation)\n\nGet average radius   LinearAlgebra.average_radius(z::InvariantCircle)\nGet the area of the invariant circle   area(z::InvariantCircle; i_circle=1, Ns = 100)\n\n\n\n\n\n","category":"type"},{"location":"lib/Documentation/#SymplecticMapTools.evaluate-Tuple{InvariantCircle, Number}","page":"Documentation","title":"SymplecticMapTools.evaluate","text":"evaluate(z::InvariantCircle, θ::Number; i_circle::Integer=1)\n\nEvaluate the i_circleth circle in z at the point θ\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.deval-Tuple{InvariantCircle, Number}","page":"Documentation","title":"SymplecticMapTools.deval","text":"deval(z::InvariantCircle, θ::Number; i_circle::Integer=1)\n\nEvaluate the derivative of the i_circleth circle in z at the point θ\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.shifted_eval","page":"Documentation","title":"SymplecticMapTools.shifted_eval","text":"shifted_eval(z::InvariantCircle, θ::AbstractVector; i_circle::Integer=1)\n\nEvaluate the i_circleth circle in z at the point θ, shifted by τ\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.get_circle_residual","page":"Documentation","title":"SymplecticMapTools.get_circle_residual","text":"get_circle_residual(F::Function, z::InvariantCircle, Nθ::Integer)\n\nGet the KAM-like residual of a chain of p invariant circles.\n>   Rᵢ₁ = z₁(θᵢ+τ) - F(z_p(θᵢ))\n>   Rᵢⱼ = zⱼ(θᵢ) - F(zⱼ₋₁(θᵢ)) for 2<=j<=p\n\nArguments:\n\nF: Symplectic map\nz: Invariant circle\nNθ: Number of θ points where the residual is taken\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.gn_circle","page":"Documentation","title":"SymplecticMapTools.gn_circle","text":"gn_circle(FJ::Function, z::InvariantCircle, Nθ::Integer;\n          maxiter::Integer=10, rtol::Number=1e-8, verbose::Bool=false,\n          monitor::Function=(z, rnorm) -> nothing,\n          constraint::Function=fixed_θ0_constraint, λ::Number=0)\n\nFind an invariant circle using Gauss-Newton with linesearch. Implemented with dense linear algebra (no FFTs yet). Returns the number of iterations taken to converge. If an evaluation fails, returns -1. If the routine fails to converge, returns -2\n\nArguments:\n\nz::InvariantCircle: An initial connecting orbit guess, see linear_initial_connecting_orbit\nFJ::Function: Function defined on R² with signature F(x), J(x) = FJ(x) where F is the symplectic map and J = dF/dx\nNθ: Number of quadrature nodes for the least squares\nmaxiter = 10: Maximum number of Gauss Newton steps\nrtol = 1e-8: Stopping tolerance\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Fourier-Circles","page":"Documentation","title":"Fourier Circles","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"FourierCircle\nget_Na(::FourierCircle)\nget_p(::FourierCircle)\nBase.length(::FourierCircle)\nget_a0\nset_a0!\nget_Am\nset_Am!\nBase.getindex(::FourierCircle, ::Integer, ::Integer)\nBase.setindex!(::FourierCircle, ::AbstractArray, ::Integer, ::Integer)\nget_τ\nset_τ!\naverage_radius(::FourierCircle)\nevaluate(::FourierCircle, ::AbstractVector)\ndeval(::FourierCircle, ::AbstractVector)\nderiv(::FourierCircle)\narea\ncircle_linear!","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.FourierCircle","page":"Documentation","title":"SymplecticMapTools.FourierCircle","text":"FourierCircle <: InvariantCircle\n\nConstructors:\n\nFourierCircle(Na::Integer; a::AbstractArray=[], τ::Number=0., p::Integer=1)\n\nFourier invariant circle data structure (see InvariantCircle), used to compute a circle z that is invariant of a map Fᵖ(z), where p is the period. This is done by storing all of the circles Fⁱ(z) for 0<=i<p. The circles are stored as Fourier series, i.e.    z(θ) = a₀ + ∑₁ᴺᵃ Aⱼ [cos(jθ), sin(jθ)]ᵀ The coefficients of the invariant circle can be accessed and set in chunks via array indexing. That is,   You can get and set a₀ of the ith circle using z[0, i]   You can get and set Aⱼ of the ith circle using z[j, i]\n\n\n\n\n\n","category":"type"},{"location":"lib/Documentation/#SymplecticMapTools.get_Na-Tuple{FourierCircle}","page":"Documentation","title":"SymplecticMapTools.get_Na","text":"get_Na(z::FourierCircle)\n\nGet number of Fourier modes\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.get_p-Tuple{FourierCircle}","page":"Documentation","title":"SymplecticMapTools.get_p","text":"get_p(z::FourierCircle)\n\nGet number of islands\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#Base.length-Tuple{FourierCircle}","page":"Documentation","title":"Base.length","text":"Base.length(z::FourierCircle)\n\nGet total number of parameters, excluding τ\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.get_a0","page":"Documentation","title":"SymplecticMapTools.get_a0","text":"get_a0(z::FourierCircle; i_circle::Integer=1)\n\nGet constant term of Fourier series of the i_circleth circle in island chain\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.set_a0!","page":"Documentation","title":"SymplecticMapTools.set_a0!","text":"set_a0!(z::FourierCircle, a0::AbstractArray; i_circle::Integer=1)\n\nSet constant term of Fourier series of the i_circleth circle in island chain\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.get_Am","page":"Documentation","title":"SymplecticMapTools.get_Am","text":"get_Am(z::FourierCircle, m::Integer; i_circle::Integer=1)\n\nGet mth Fourier coefficients of the i_circleth circle in island chain\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.set_Am!","page":"Documentation","title":"SymplecticMapTools.set_Am!","text":"set_Am!(z::FourierCircle, m::Integer, a::AbstractArray; i_circle::Integer=1)\n\nSet mth Fourier coefficients of the i_circleth circle in island chain\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Base.getindex-Tuple{FourierCircle, Integer, Integer}","page":"Documentation","title":"Base.getindex","text":"Base.getindex(z::FourierCircle, i_A::Integer, i_circle::Integer)\n\nGet the coefficients of z. z[0, i_circle] gets the constant term. z[i_A, i_circle] gets higher coefficients\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#Base.setindex!-Tuple{FourierCircle, AbstractArray, Integer, Integer}","page":"Documentation","title":"Base.setindex!","text":"Base.setindex!(z::FourierCircle, X::AbstractArray, i_A::Integer,\n               i_circle::Integer)\n\nSet the coefficients of z. z[0, i_circle] sets the constant term. z[i_A, i_circle] sets higher coefficients\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.get_τ","page":"Documentation","title":"SymplecticMapTools.get_τ","text":"get_τ(z::FourierCircle)\n\nGet the rotation number (the circle is 2π periodic)\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.set_τ!","page":"Documentation","title":"SymplecticMapTools.set_τ!","text":"set_τ!(z::FourierCircle, τ::Number)\n\nSet the rotation number (the circle is 2π periodic)\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.average_radius-Tuple{FourierCircle}","page":"Documentation","title":"SymplecticMapTools.average_radius","text":"average_radius(z::FourierCircle)\n\nNorm defined as the L2 norm of the radius, i.e. ‖z‖² = 1/2πp ∫ ||z(θ) - a₀||^2 dθ      = 1/2p ∑ₖ Tr(AₖᵀAₖ) If i_circle = 0, takes the norm over all circles. If i_circle != 0, finds the average radius of a single circle.\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.evaluate-Tuple{FourierCircle, AbstractVector}","page":"Documentation","title":"SymplecticMapTools.evaluate","text":"evaluate(z::FourierCircle, θ::AbstractVector{T}; i_circle::Integer=1) where {T}\n\nEvaluate the i_circleth circle in the chain at a vector of points θ\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.deval-Tuple{FourierCircle, AbstractVector}","page":"Documentation","title":"SymplecticMapTools.deval","text":"deval(z::FourierCircle, θ::AbstractVector; i_circle::Integer=1)\n\nEvaluate the derivative of the i_circleth circle in the chain at a vector of points θ\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.deriv-Tuple{FourierCircle}","page":"Documentation","title":"SymplecticMapTools.deriv","text":"deriv(z::FourierCircle)\n\nReturn the derivative of the FourierCircle, wrapped in a circle object\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.area","page":"Documentation","title":"SymplecticMapTools.area","text":"area(z::FourierCircle; i_circle=1)\n\nGet the area of the circle.\n\n\n\n\n\narea(c::ConnectingOrbit; origin::AbstractArray=[0.0,0.0],\n     i_p::Integer=1, rtol=1e-8)\n\nGet the \"area\" of a connecting orbit ∫₋₁¹ (x dy/ds - y dy/ds) ds\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.circle_linear!","page":"Documentation","title":"SymplecticMapTools.circle_linear!","text":"circle_linear!(z::FourierCircle, FJ::Function, x::AbstractArray, h::Number)\n\nFill z's Fourier coefficients using a linearization about a stable periodic orbit. Useful for seeding continuation.\n\nArguments:\n\nz: An invariant circle\nFJ: A function that returns the map and its derivative F, dFdx = FJ(x)\nx: A periodic orbit of F\nh: The average radius of the first linearized invariant circle\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Connecting-Orbits","page":"Documentation","title":"Connecting Orbits","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"ConnectingOrbit\nget_Na(::ConnectingOrbit)\nget_p(::ConnectingOrbit)\nget_am(::ConnectingOrbit, ::Integer)\nset_am!(::ConnectingOrbit, ::Integer, ::AbstractArray)\nBase.getindex(::ConnectingOrbit, ::Integer, ::Integer)\nBase.setindex!(::ConnectingOrbit, ::AbstractArray, ::Integer, ::Integer)\nevaluate(::ConnectingOrbit, ::AbstractArray)\nevaluate(::ConnectingOrbit, ::Number)\ndeval(::ConnectingOrbit, ::Number)\narea(::ConnectingOrbit)\nlinear_initial_connecting_orbit\ngn_connecting!","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.ConnectingOrbit","page":"Documentation","title":"SymplecticMapTools.ConnectingOrbit","text":"ConnectingOrbit(Na::Integer, p::Integer)\n\nInitialize a connecting orbit consisting of p segments cⱼ : [0,1] -> R². The endpoints cⱼ(0) and cⱼ(1) are both hyperbolic perodic orbits. The connecting orbits connect these, acting as the outer boundary of an island. The connecting orbits are parameterized by Chebyshev polynomials of degree Na.\n\nSee linear_initial_connecting_orbit and gn_connecting! for functions to initialize and compute a connecting orbit.\n\n\n\n\n\n","category":"type"},{"location":"lib/Documentation/#SymplecticMapTools.get_Na-Tuple{ConnectingOrbit}","page":"Documentation","title":"SymplecticMapTools.get_Na","text":"get_Na(c::ConnectingOrbit)\n\nGet the polynomial degree of the connecting orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.get_p-Tuple{ConnectingOrbit}","page":"Documentation","title":"SymplecticMapTools.get_p","text":"get_p(c::ConnectingOrbit)\n\nGet the period of the connecting orbit\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.get_am-Tuple{ConnectingOrbit, Integer}","page":"Documentation","title":"SymplecticMapTools.get_am","text":"get_am(c::ConnectingOrbit, m::Integer; i_p::Integer=1)\n\nGet the mth Chebyshev coefficient of the i_pth connecting orbit\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.set_am!-Tuple{ConnectingOrbit, Integer, AbstractArray}","page":"Documentation","title":"SymplecticMapTools.set_am!","text":"set_am!(c::ConnectingOrbit, m::Integer, am::AbstractArray; i_p::Integer=1)\n\nSet the mth Chebyshev coefficient of the i_pth connecting orbit\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#Base.getindex-Tuple{ConnectingOrbit, Integer, Integer}","page":"Documentation","title":"Base.getindex","text":"Base.getindex(c::ConnectingOrbit, i_A::Integer, i_p::Integer)\n\nWrapper for get_am.\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#Base.setindex!-Tuple{ConnectingOrbit, AbstractArray, Integer, Integer}","page":"Documentation","title":"Base.setindex!","text":"Base.setindex!(c::ConnectingOrbit, X::AbstractArray, i_A::Integer, i_p::Integer)\n\nWrapper for set_am!\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, AbstractArray}","page":"Documentation","title":"SymplecticMapTools.evaluate","text":"evaluate(c::ConnectingOrbit, x::AbstractArray; i_p::Integer=1)\n\nEvaluate the i_pth connecting orbit at a set of points x[j] in [0,1]\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, Number}","page":"Documentation","title":"SymplecticMapTools.evaluate","text":"evaluate(c::ConnectingOrbit, x::Number; i_p::Integer=1)\n\nEvaluate the i_pth connecting orbit at a point x in [0,1]\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.deval-Tuple{ConnectingOrbit, Number}","page":"Documentation","title":"SymplecticMapTools.deval","text":"deval(c::ConnectingOrbit, x::Number; i_p::Integer=1)\n\nEvaluate the derivative of the i_pth connecting orbit at a point x in [0,1]\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.area-Tuple{ConnectingOrbit}","page":"Documentation","title":"SymplecticMapTools.area","text":"area(c::ConnectingOrbit; origin::AbstractArray=[0.0,0.0],\n     i_p::Integer=1, rtol=1e-8)\n\nGet the \"area\" of a connecting orbit ∫₋₁¹ (x dy/ds - y dy/ds) ds\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.linear_initial_connecting_orbit","page":"Documentation","title":"SymplecticMapTools.linear_initial_connecting_orbit","text":"linear_initial_connecting_orbit(x0, x1, Na::Integer)\n\nInitialize a ConnectingOrbit of degree Na using the two hyperbolic orbits x0 and x1 of the form xn = [xn0, F(xn0), ..., F^(p-1)(xn0)].\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.gn_connecting!","page":"Documentation","title":"SymplecticMapTools.gn_connecting!","text":"gn_connecting!(c::ConnectingOrbit, FJ::Function, ends::AbstractArray;\n               Ns = 100, maxiters = 10, rtol = 1e-8, verbose=false)\n\nFind a connecting orbit using Gauss Newton with linesearch.\n\nArguments:\n\nc::ConnectingOrbit: An initial connecting orbit guess, see linear_initial_connecting_orbit\nFJ::Function: Function defined on R² with signature  F(x), J(x) = FJ(x) where F is the symplectic map and J = dF/dx\nends::AbstractArray: A 2p × 2 matrix containing the end periodic orbits [x00, x10; F(x00), F(x10); ... ; F^(p-1)(x00), F^(p-1)(x10)]\nNs = 100: Number of quadrature nodes for the least squares\nmaxiters = 10: Maximum number of Gauss Newton steps\nrtol = 1e-8: Stopping tolerance\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Kernel-Labels","page":"Documentation","title":"Kernel Labels","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"KernelLabel\nget_matrix(::KernelLabel, ::AbstractArray)\nevaluate(::KernelLabel, ::AbstractArray)\nwindow_weight\nrectangular_window_weight\nkernel_sample_F\nkernel_eigs\nkernel_bvp\nget_energies\nkernel_birkhoff","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.KernelLabel","page":"Documentation","title":"SymplecticMapTools.KernelLabel","text":"KernelLabel\n\nConstructors:\n\nKernelLabel(x::AbstractArray, c::AbstractVector, σ::Number;               kernel::Symbol=:SquaredExponential)\nKernelLabel(x::AbstractArray, c::AbstractVector, σ::AbstractArray;               kernel::Symbol=:SquaredExponential)\n\nAn approximately invariant kernel label function.\n\nConstructor elements:\n\nx: The d × 2N array of interpolating points, where x[:, n+N] = F(x[:, n]) for n<=N and some symplectic map F.\nc: The length 2N vector of coefficients of the kernel function\nσ: The length scale of the kernel (if a vector, length scale is different in different directions)\nkernel: The type of kernel used\n\nThe current supported kernels are:\n\n:SquaredExponential: The squared exponential kernel   K(x, y) = exp(-|x-y|²)\n:InverseMultiquadric: The β=1 Inverse Multiquadric kernel   K(x, y) = (1+|x-y|²)^(-1/2)\n:FourierSE: The Fourier × Cartesian squared exponential kernel   K(x, y) = exp(-sin²(x₁-y₁) - (x₂-y₂)²)\n:Fourier: The Fourier × Fourier squared exponential kernel   K(x, y) = exp(-sin²(x₁-y₁) - sin²(x₂-y₂))\n\n\n\n\n\n","category":"type"},{"location":"lib/Documentation/#SymplecticMapTools.get_matrix-Tuple{KernelLabel, AbstractArray}","page":"Documentation","title":"SymplecticMapTools.get_matrix","text":"get_matrix(k::KernelLabel, x::AbstractArray)\n\nGet the kernel matrix K[i,j] = K(k.x[:,i], x[:,j])\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.evaluate-Tuple{KernelLabel, AbstractArray}","page":"Documentation","title":"SymplecticMapTools.evaluate","text":"evaluate(k::KernelLabel, x::AbstractArray)\n\nEvaluate the kernel matrix at the columns of x\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.window_weight","page":"Documentation","title":"SymplecticMapTools.window_weight","text":"window_weight(xs::AbstractArray, lims::AbstractVector, α::Number;\n                   ind::Integer=2)\n\nA simple boundary weighting function for kernel_eigs and kernel_bvp. Returns a weight that is approximately 1 outside of lims and 0 inside via the sum of two logistic functions.\n\nArguments:\n\nxs: A d × N array of points, where d is the size of the phase space and N is the number of points.\nlims: A 2-vector giving the interval where the weight is approximately 0\nα: The length scale of the logistic functions (typically small relative to the size of the domain)\nind=2: The index over which the window is applied. Defaults to 2 for maps on T×R (such as the standard map)\n\nOutput:\n\nw: A N-vector with the window weights\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.rectangular_window_weight","page":"Documentation","title":"SymplecticMapTools.rectangular_window_weight","text":"rectangular_window_weight(xs::AbstractArray, xlims::AbstractVector,\n                          ylims::AbstractVector, α::Number)\n\nA simple boundary weighting function for kernel_eigs and kernel_bvp. Returns a weight that is approximately 1 outside of xlims × ylims and 0 inside via the a function of logistic functions.\n\nArguments:\n\nxs: A d × N array of points, where d is the size of the phase space and N is the number of points.\nxlims and ylims: 2-vectors giving the rectangle where the weight is approximately 0\nα: The length scale of the logistic functions (typically small relative to the size of the domain)\n\nOutput:\n\nw: A N-vector with the window weights\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.kernel_sample_F","page":"Documentation","title":"SymplecticMapTools.kernel_sample_F","text":"kernel_sample_F(F::Function, N::Integer, xb::AbstractVector,\n                yb::AbstractVector)\n\nSobol sample N points in the rectangle xb × yb. Then, evaluate F at each point. Input can be used for kernel_eigs and kernel_bvp\n\nArguments:\n\nF: The symplectic map from the state space to itself\nN: The number of points to be sampled\nxb × yb: The 2-vector bounds of the rectangle to be sampled\n\nOutput:\n\nxs: A 2 × 2N array of samples compatable with kernel_eigs and kernel_bvp, of the form [x_1, F(x_1), x_2, F(x_2), ...]\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.kernel_eigs","page":"Documentation","title":"SymplecticMapTools.kernel_eigs","text":"kernel_eigs(xs::AbstractArray, ϵ::Number, nev::Integer, σ::Number,\n            boundary_weights::Vector; kernel::Symbol=:SquaredExponential,\n            zero_mean = false, check = 1)\n\nSolve the the invariant eigenvalue problem, given by the Rayleigh quotient\n> min_c (‖GKc‖² + ‖Kc‖²_bd + ϵ‖c‖²_k)/‖Kc‖² \nwhere\n\n‖GKc‖² is a norm penalizing invariance (and possible a non-zero mean)\n‖Kc‖²_bd is a norm penalizing boundary violation\n‖c‖²_k is the smoothing kernel norm\n‖Kc‖² is the ℓ² norm of the points\n\nThe eigenvalue problem is solved via Arpack.jl\n\nArguments:\n\nxs: interpolation points of size d × 2N, where xs[:, N+1:2N] = F.(xs[:, 1:N])\nϵ: Amount of regularization\nnev: Number of eigenvalues to find\nσ: Kernel width\nboundary_weights: Boundary weighting vector, should be positive and O(1) at points x where one wants |k(x)| << 1\nkernel: Type of kernel to interpolate (see KernelLabel)\nzero_mean = false: Set to true to add a constraint that encourages k to have a zero mean. Useful when xs are sampled on an invariant set and boundary_weights=0\ncheck = 1: See Arpack.eigs. If 1, return all of the converged eigenvectors and eigenvalues. If 0, throw an error instead.\n\nOutput:\n\nλs: The eigenvalues\nvs: The eigenvectors\nk: The kernel label. Use set_c!(k, vs[:,n]) to load the nth eigenvector into k. By default, k stores the lowest order eigenvector.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.kernel_bvp","page":"Documentation","title":"SymplecticMapTools.kernel_bvp","text":"kernel_bvp(xs::AbstractArray, ϵ::Number, σ::Number,\n           boundary_weights::AbstractVector,\n           boundary_values::AbstractVector;\n           kernel::Symbol=:SquaredExponential, residuals::Bool=true)\n\nSolve the the invariant boundary value least-squares problem\n> min_c ‖GKc‖² + ‖Kc - h_{bd}‖²_bd + ϵ‖c‖²_k = R_inv + R_bd + R_eps\nwhere\n\n‖GKc‖² is a norm penalizing invariance (and possible a non-zero mean)\n‖Kc - h_{bd}‖²_bd is a norm penalizing the function from violating the boundary condition\n‖c‖²_k is the smoothing kernel norm\n\nArguments:\n\nxs: interpolation points of size d × 2N, where xs[:, N+1:2N] = F.(xs[:, 1:N])\nϵ: Amount of regularization\nσ: Kernel width\nboundary_weights: Length 2N boundary weighting vector, should be positive and O(1) at points x where one wants |k(x)| << 1\nboundary_values: Length 2N boundary value vector, indicating the value the function should take at each point\nkernel=:SquaredExponential: Type of kernel to interpolate (see KernelLabel)\nresiduals=true: True if you want the problem to return residuals.\n\nOutput:\n\nk: The kernel function\n\n(if residuals=true)\n\nR: The total residual\nR_bd: The boundary condition residual\nR_inv: The invariance residual\nR_eps: The smoothness residual\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.get_energies","page":"Documentation","title":"SymplecticMapTools.get_energies","text":"get_energies(k::KernelLabel; W = 0. * I)\n\nGet the relevant energies of a kernel label k with boundary weighting matrix W.\n\nOutput energies:\n\nEK = ‖c‖²_k is the smoothing kernel norm\nEInv = ‖GKc‖² is a norm penalizing invariance\nEbd = ‖Kc‖²_W is a norm penalizing boundary violation\nEL2 = ‖Kc‖² is the ℓ² norm of the points\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.kernel_birkhoff","page":"Documentation","title":"SymplecticMapTools.kernel_birkhoff","text":"kernel_birkhoff(xs::AbstractArray, fs::AbstractVector, ϵ::Number, μ::Number;\n                σ::Number=0., kernel::Symbol=:SquaredExponential,\n                boundary_points::AbstractVector = [])\n\nThis function is mostly deprecated. The solutions to the infinitely discretized limit of this problem (the Birkhoff average) don't live in the native space. So, the results can be odd, hard to interpret, and wiggly. Use at your own risk.\n\nFind the \"Birkhoff average\" of a function using the kernel approach. Solves the least-squares problem\n> min_c μ⁻¹(‖GKc‖² + ‖Kc‖²_bd) + ϵ‖c‖²_k + ‖Kc - f‖²\nwhere\n\n‖GKc‖² is a norm penalizing invariance\n‖c‖²_k is the smoothing kernel norm\n‖Kc - f‖² is a least-squares fit norm\n‖Kc‖²_bd is a norm penalizing boundary violation\n\nArguments:\n\nxs: interpolation points of size d × 2N, where xs[:, N+1:2N] = F.(xs[:, 1:N])\nfs: function values at points of size N\nϵ: Amount of regularization (can be set to zero)\nμ: Weighting of invariance penalization to fit (should be small, e.g. 1e-6)\nσ: Scale of the problem\nkernel: Type of kernel to interpolate (see KernelLabel)\nboundary_points: A list of indices of points on the boundary\n\nOutput:\n\nk: A KernelLabel object\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Continued-Fractions","page":"Documentation","title":"Continued Fractions","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"ContFrac\nbig_cont_frac_eval\nevaluate(::ContFrac)\npartial_frac\ndenoms\nbig_partial_frac\nbig_denoms","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.ContFrac","page":"Documentation","title":"SymplecticMapTools.ContFrac","text":"ContFrac(a::AbstractArray)\n\nA continued fraction in (0,1]. The member a is a vector of the continued fraction coefficients so that ω = 1/(a[1] + 1/(a[2] + ...))\n\n\n\n\n\n","category":"type"},{"location":"lib/Documentation/#SymplecticMapTools.big_cont_frac_eval","page":"Documentation","title":"SymplecticMapTools.big_cont_frac_eval","text":"big_cont_frac_eval(c::ContFrac)\n\nFind a high precision representation of the continued fraction as a BigFloat. To set the precision, use precision.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.evaluate-Tuple{ContFrac}","page":"Documentation","title":"SymplecticMapTools.evaluate","text":"evaluate(c::ContFrac)\n\nFind a floating point representation of the continued fraction.\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.partial_frac","page":"Documentation","title":"SymplecticMapTools.partial_frac","text":"partial_frac(c::ContFrac, n::Integer)\n\nFind the nth convergent of the continued fraction c as a rational number.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.denoms","page":"Documentation","title":"SymplecticMapTools.denoms","text":"denoms(c::ContFrac)\n\nReturn a list of the denominators of the continued fractions of c\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.big_partial_frac","page":"Documentation","title":"SymplecticMapTools.big_partial_frac","text":"big_partial_frac(c::ContFrac, n::Integer)\n\nFind the nth convergent of the continued fraction c as a rational number as  BigInts. Set the precision with precision.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.big_denoms","page":"Documentation","title":"SymplecticMapTools.big_denoms","text":"big_denoms(c::ContFrac)\n\nReturn a list of the denominators of the continued fractions of c as BigInts. Set the precision with precision.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Birkhoff-Extrapolation","page":"Documentation","title":"Birkhoff Extrapolation","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"vector_mpe_backslash\nvector_mpe_iterative\nwba_weight\nweighted_birkhoff_average\ndoubling_birkhoff_average\nbirkhoff_extrapolation\nadaptive_birkhoff_extrapolation\nsum_stats\nget_sum_ave\nget_circle_info","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.vector_mpe_backslash","page":"Documentation","title":"SymplecticMapTools.vector_mpe_backslash","text":"vector_mpe_backslash(x::AbstractArray, K::Integer)\n\nApplies Birkhoff vector MPE to a sequence x_n = x[:, n]\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.vector_mpe_iterative","page":"Documentation","title":"SymplecticMapTools.vector_mpe_iterative","text":"vector_mpe_backslash(x::AbstractArray, K::Integer)\n\nApplies Birkhoff vector MPE to a sequence x_n = x[:, n] using the LSQR algorithm. This currently does not have preconditioning, and therefore is less accurate than vector_mpe_backslash.\n\nArguments:\n\nx: The sequence\nK: The number of unknowns in the filter\nc0: The initial guess of\natol, btol: Tolerances. See IterativeSolvers.lsqr!\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.wba_weight","page":"Documentation","title":"SymplecticMapTools.wba_weight","text":"wba_weight(d, N)\n\nWeights used in the weighted Birkhoff average, returned as a diagonal matrix. Returns as Diagonal([w_1, ..., w_1, ..., w_N, ..., w_N]), where each coefficient is repeated d times (this is used for vector MPE and RRE as a least-squares weighting)\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.weighted_birkhoff_average","page":"Documentation","title":"SymplecticMapTools.weighted_birkhoff_average","text":"weighted_birkhoff_average(hs::AbstractMatrix)\n\nFinds a weighted Birkhoff average of a sequence of vector observations. The array input is assumed to be of size d × N, where the average is performed over the second index.\n\n\n\n\n\nweighted_birkhoff_average(hs::AbstractVector)\n\nFinds a weighted Birkhoff average of a sequence of scalar observations.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.doubling_birkhoff_average","page":"Documentation","title":"SymplecticMapTools.doubling_birkhoff_average","text":"doubling_birkhoff_average(h::Function, F::Function, x0::AbstractVector;\n                          tol::Number = 1e-10, T_init::Integer=10,\n                          T_max::Integer=320)\n\nFind the weighted Birkhoff ergodic average of an observable function h over a trajectory of the map F adaptively.\n\nArguments:\n\nh: A function from Rᵈ to Rⁿ, where d is the dimension of the state space and n is the dimension of the observation\nF: The (symplectic) map: a function from Rᵈ to Rᵈ\nx0: The initial point of the trajectory in Rᵈ\ntol: The tolerance by which convergence is judged. If the average does not change by more than tol over a doubling, the function returns\nT_init: The initial length of the trajectory considered\nT_max: The maximum trajectory length considered\n\nOutput:\n\nave: The average of h over the trajectory\nxs: The trajectory\nhs: The value of h on the trajectory\nconv_flag: true iff the averages converged\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.birkhoff_extrapolation","page":"Documentation","title":"SymplecticMapTools.birkhoff_extrapolation","text":"birkhoff_extrapolation(h::Function, F::Function, x0::AbstractVector,\n                       N::Integer, K::Integer; iterative::Bool=true,\n                       x_prev::Union{AbstractArray,Nothing}=nothing,\n                       rre::Bool=false)\n\nAs input, takes an initial point x0, a symplectic map F, and an observable h (can choose the identity as a default h = (x)->x). Then, the method\n\nComputes a time series xs[:,n+1] = Fⁿ(x0)\nComputes observable series hs[:,n] = h(xs[:,n])\nPerforms sequence extrapolation (RRE or MPE) on hs to obtain a model c of  length 2K+1 (with K unknowns), the extrapolated value applied to each  window, and a residual\nReturns as c, sums, resid, xs, hs[, history] where history is a  diagnostic from the iterative solver that only returns when iterative=true\n\nUse x_prev if you already know part of the sequence, but do not know the whole thing.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.adaptive_birkhoff_extrapolation","page":"Documentation","title":"SymplecticMapTools.adaptive_birkhoff_extrapolation","text":"adaptive_birkhoff_extrapolation(h::Function, F::Function,\n                x0::AbstractVector; rtol::Number=1e-12, Kinit = 20,\n                Kmax = 100, Kstride=20, iterative::Bool=true,\n                Nfactor::Integer=1, rre::Bool=false)\n\nAdaptively applies birkhoff_extrapolation to find a good enough filter length K, where \"good enough\" is defined by the rtol optional argument.\n\nArguments:\n\nh: The observable function (can choose the identity as a default h = (x)->x)\nF: The symplectic map\nx0: The initial point of the trajectory\nrtol: Required tolerance for convergence (inexact maps often require a looser tolerance)\nKinit: The length of the initial filter\nKmax: The maximum allowed filter size\nKstride: The amount K increases between applications of            birkhoff_extrapolation\niterative: Whether to use an iterative method to solve the Hankel system              in the extrapolation step\nNfactor: How rectangular the extrapolation algorithm is. Must be >=1.\nrre: Turn to true to use reduced rank extrapolation instead of minimal        polynomial extrapolation.\n\nOutputs:\n\nc: Linear model / filter\nsums: The extrapolated value applied to each window\nresid: The least squares residual\nxs: A time series x[:,n] = Fⁿ(x[:,0])\nhs: The observations h[:,n] = h(x[:,n])\nrnorm: The norm of resid\nK: The final degree of the filter\nhistory: Returned if iterative=true. The history of the final LSQR iteration\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.sum_stats","page":"Documentation","title":"SymplecticMapTools.sum_stats","text":"sum_stats(sums)\n\nGiven a sequence of sums applied to a filter (an output of invariant circle extrapolation), find the average and standard deviation of the sums. Can be used as a measure of how \"good\" the filter is.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.get_sum_ave","page":"Documentation","title":"SymplecticMapTools.get_sum_ave","text":"get_sum_ave(hs, c)\n\nGiven a signal hs (of size either d×N or N×1) and a filter c of size M×1, compute the average of the M-N windows of the filter applied to the signal.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.get_circle_info","page":"Documentation","title":"SymplecticMapTools.get_circle_info","text":"get_circle_info(hs::AbstractArray, c::AbstractArray; rattol::Number=1e-8,\n                ratcutoff::Number=1e-4, max_island_d::Integer=30)\n\nGet a Fourier representation of an invariant circle from the observations hs and the learned filter c (see adaptive_invariant_circle_model and invariant_circle_model to find the filter). See get_circle_residual for an a posteriori validation of the circle.\n\nOptional Arguments:\n\nrattol: Roots are judged to be rational if |ω-m/n|<rattol\nratcutoff: Relative prominence needed by a linear mode to qualify as \"important\" for deciding whether the sequence is an island\nmax_island_d: Maximum denominator considered for islands.\n\nOutput:\n\nz: An invariant circle of type FourierCircle\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Example-Maps","page":"Documentation","title":"Example Maps","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"standard_map_F\nstandard_map_FJ\npolar_map","category":"page"},{"location":"lib/Documentation/#SymplecticMapTools.standard_map_F","page":"Documentation","title":"SymplecticMapTools.standard_map_F","text":"standard_map_F(k)\n\nReturns the Chirikov standard map with parameter k.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.standard_map_FJ","page":"Documentation","title":"SymplecticMapTools.standard_map_FJ","text":"standard_map_FJ(k)\n\nReturns a function FJ that returns the Chirikov standard map and its derivative (i.e. F, dFdx = FJ(x)) with parameter k.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#SymplecticMapTools.polar_map","page":"Documentation","title":"SymplecticMapTools.polar_map","text":"polar_map(;z0 = -0.5)\n\nReturns the polar map \n> h:(θ,z)->((z-z0)cos(2πθ), (z-z0)sin(2πθ))\nas well as its derivative HJ, its inverse hinv, and its inverse derivative HJinv. Useful for applying extrapolation methods to maps on T×R. Default value of z0 is useful for the standard map on T×[0,1] with k=0.7.\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#Plotting-Routines:-Plots","page":"Documentation","title":"Plotting Routines: Plots","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"Plots.plot(::InvariantCircle)\nPlots.plot!(::Plots.Plot, ::InvariantCircle)\nparametric_plot\nPlots.plot(::ConnectingOrbit)\nPlots.plot!(::Plots.Plot, ::ConnectingOrbit)","category":"page"},{"location":"lib/Documentation/#RecipesBase.plot-Tuple{InvariantCircle}","page":"Documentation","title":"RecipesBase.plot","text":"Plots.plot(z::InvariantCircle; kwargs...)\n\nCreates a plot of the invariant circle z. See Plots.plot!(z::InvariantCircle) for a list of keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#RecipesBase.plot!-Tuple{Plots.Plot, InvariantCircle}","page":"Documentation","title":"RecipesBase.plot!","text":"Plots.plot(p::Plots.Plot, z::InvariantCircle; kwargs...)\n\nPlots the invariant circle z on p.\n\nkwargs:\n\nN::Integer: Number of θ points used to plot each circle\ni_circle::Integer: Which period of an island chain to plot. Default value of 0 plots all circles of an island chain.\nlabel, color, linewidth, linestyle: see Plots.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.parametric_plot","page":"Documentation","title":"SymplecticMapTools.parametric_plot","text":"parametric_plot(z::InvariantCircle; N::Integer=200, i_circle::Integer=1,\n                linewidth=1, linestyle=:solid, label1=\"x\", label2=\"y\",\n                xlabel=\"θ\", plot_min_dθs=true, markersize=5)\n\nParametric plot of an invariant circle.\n\nkwargs:\n\nN::Integer: Number of θ points used to plot each circle\ni_circle::Integer: Which period of an island chain to plot\n\n\n\n\n\n","category":"function"},{"location":"lib/Documentation/#RecipesBase.plot-Tuple{ConnectingOrbit}","page":"Documentation","title":"RecipesBase.plot","text":"Plots.plot(c::ConnectingOrbit; kwargs...)\n\nCreates a plot of the connecting orbit c. See Plots.plot!(c::ConnectingOrbit) for a list of keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#RecipesBase.plot!-Tuple{Plots.Plot, ConnectingOrbit}","page":"Documentation","title":"RecipesBase.plot!","text":"Plots.plot!(p::Plots.Plot, c::ConnectingOrbit; kwargs...)\n\nCreates a plot of the connecting orbit c.\n\nkwargs:\n\nN::Integer: Number of points used to plot each orbit\ni_circle::Integer: Which period of a connecting orbit chain to plot. Default value of 0 plots all connecting orbits of a island chain.\nlabel, color, linewidth: see Plots.jl\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#Plotting-Routines:-CairoMakie","page":"Documentation","title":"Plotting Routines: CairoMakie","text":"","category":"section"},{"location":"lib/Documentation/","page":"Documentation","title":"Documentation","text":"CairoMakie.lines!(::Any, ::InvariantCircle)\nlines_periodic!(::Any, ::InvariantCircle, ::Function)\nplot_on_grid(::AbstractVector, ::AbstractVector, ::KernelLabel)\npoincare_plot(::AbstractVector, ::AbstractVector, ::Function, ::Integer, ::Integer)","category":"page"},{"location":"lib/Documentation/#MakieCore.lines!-Tuple{Any, InvariantCircle}","page":"Documentation","title":"MakieCore.lines!","text":"CairoMakie.lines!(ax, z::InvariantCircle; N::Integer=100, color=nothing,                      i_circle::Integer=0, linewidth=1)\n\nPlot the invariant circle z on the CairoMakie axis ax.\n\nArguments:\n\nax: CairoMakie Axis object\nz: The circle in R² to be plotted\nN: Number of points to plot\ni_circle: Which invariant circle of an island to plot. If 0, plot all\ncolor, linewidth: see CairoMakie.lines!\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.lines_periodic!-Tuple{Any, InvariantCircle, Function}","page":"Documentation","title":"SymplecticMapTools.lines_periodic!","text":"lines_periodic!(ax, z::InvariantCircle, hinv::Function; N::Integer=100,\n                color=nothing, i_circle::Integer=0, linewidth=1)\n\nUseful for plotting with invariant circles on the torus. I.e., if F : T×R→T×R, and one finds an invariant circle of z(θ+τ) = (h∘F)(z(θ)) where h : T×R→R², this plots h⁻¹∘z, the original invariant circle.\n\nArguments:\n\nax: CairoMakie Axis object\nz: The circle in R² to be plotted\nhinv: The map to the torus by the real numbers h⁻¹ : R²→T×R\nN: Number of points to plot\ni_circle: Which invariant circle of an island to plot. If 0, plot all\ncolor, linewidth, label: see CairoMakie.lines!\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.plot_on_grid-Tuple{AbstractVector, AbstractVector, KernelLabel}","page":"Documentation","title":"SymplecticMapTools.plot_on_grid","text":"plot_on_grid(x::AbstractVector, y::AbstractVector, k::KernelLabel;\n             kwargs...)\n\nCreate a filled contour plot of the kernel label k on the x × y grid.\n\nkwargs:\n\nbalance=true: If true, makes the maximum value of the color scale equal to the minimum\nresolution, fontsize: See CairoMakie.Figure\nxlabel, ylabel, title: See CairoMakie.Axis\nlevels, linewidth: See CairoMakie.contour!\nclabel: See CairoMakie.Colorbar\n\nOutput:\n\nf: The CairoMakie Figure\nf_grid: The data used to make the figure\n\n\n\n\n\n","category":"method"},{"location":"lib/Documentation/#SymplecticMapTools.poincare_plot-Tuple{AbstractVector, AbstractVector, Function, Integer, Integer}","page":"Documentation","title":"SymplecticMapTools.poincare_plot","text":"poincare_plot(xb::AbstractVector, yb::AbstractVector, F::Function,\n              Ninit::Integer, Niter::Integer; resolution=(800, 800),\n              fontsize=25, xlabel=\"x\", ylabel=\"y\", xlims = nothing,\n              ylims=nothing, markersize=3, title=\"Poincare Plot\")\n\nCreate a Poincare plot of a 2D map F in a rectangular region xb×yb. The Poincare plot uses Ninit trajectories of length Niter.\n\nOutput:\n\nf: The figure\nxs: The trajectories used to make the figure\n\n\n\n\n\n","category":"method"}]
}
