<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Approximately Invariant Kernel Functions · SymplecticMapTools</title><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">SymplecticMapTools</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">SymplecticMapTools.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../birkhoff_averaging/birkhoff_averaging/">Birkhoff Averages</a></li><li><a class="tocitem" href="../../extrapolation/extrapolation/">Birkhoff Extrapolation</a></li><li class="is-active"><a class="tocitem" href>Approximately Invariant Kernel Functions</a></li></ul></li><li><a class="tocitem" href="../../../lib/Documentation/">Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Approximately Invariant Kernel Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Approximately Invariant Kernel Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/main/docs/kernel.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Kernel-Method-for-Finding-Invariant-Circles"><a class="docs-heading-anchor" href="#Kernel-Method-for-Finding-Invariant-Circles">Kernel Method for Finding Invariant Circles</a><a id="Kernel-Method-for-Finding-Invariant-Circles-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-Method-for-Finding-Invariant-Circles" title="Permalink"></a></h1><p>Here, we will show examples of the <code>kernel_eigs</code> and <code>kernel_bvp</code> functions, which find approximately invariant functions of a symplectic map. To be more specific, let <span>$F : \Omega \to \Omega$</span> be a symplectic map. An approximately invariant function <span>$h$</span> is one that satisfies</p><p class="math-container">\[\lVert h\circ F - h \rVert \ll \lVert h \rVert,\]</p><p>for some norm. We find the function <span>$h$</span> by discretizing it via kernels, i.e. for a positive (semi)definite kernel <span>$K : \Omega \times \Omega \to \mathbb{R}$</span>, we define the kernel function on the data <span>$y_n \in \Omega$</span> as</p><p class="math-container">\[h(x) = \sum_{n = 1}^{2N}c_n K(x, y_n).\]</p><p>For the points <span>$y_n$</span>, we first sample a sequence <span>$x_1, x_2, \dots, x_N$</span> in some domain <span>$U \in \Omega$</span>. Then, we evaluate <span>$F(x_n)$</span>, giving the sequence <span>$y_1 = x_1$</span>, <span>$y_2 = F(x_1)$</span>, <span>$y_3 = x_2$</span>, <span>$y_4 = F(x_2)$</span>, etc.</p><p><code>SymplecticMapTools</code> comes equipped with sampling schemes for rectangular domains. Consider the symplectic map:</p><pre><code class="language-julia hljs">using SymplecticMapTools
using CairoMakie
using LinearAlgebra</code></pre><pre><code class="language-julia hljs">k_sm = 0.3;
F = standard_map_F(k_sm);

N = 500
xb = [0., 1.]
yb = [0., 1.]
xs = kernel_sample_F(F, N, xb, yb);
ylims = yb
f, xs_pp = SymplecticMapTools.poincare_plot([0,1], [0,1], F, N, 500; ylims, resolution=(600, 600),
                         title=&quot;Standard Map, k = $(k_sm)&quot;)
ax = contents(f[1, 1])
plot!(xs[1,1:2:end], xs[2,1:2:end], color=:black, markersize=7, label=L&quot;x_n&quot;)
plot!(xs[1,2:2:end], xs[2,2:2:end], color=:blue, markersize=7, label=L&quot;F(x_n)&quot;)
axislegend()

f</code></pre><p><img src="../kernel-4.png" alt/></p><p>Above is a Poincare plot of the standard map with <span>$k = 0.3$</span>, along with the points <span>$y_n$</span> used for the kernel method. Now, to apply the method, we also need weights for boundary conditions <span>$w_{\mathrm{bd}}:\Omega \to \mathbb{R}$</span>. The boundary condition weight function should be equal to <span>$1$</span> where you want to enforce boundary conditions, and <span>$0$</span> where you do not. It is typically best for it to be chosen smooth in between as well. One good option for this is to use a sum of logistic functions. A simple version of this is implemented in <code>window_weight</code> for maps in <span>$\mathbb{T} \times \mathbb{R}$</span> and <code>rectangular_window_weight</code> for maps in <span>$\mathbb{R}^2$</span>:</p><pre><code class="language-julia hljs">lims = [0.01, 0.99]; # window size, includes the boundaries
α = 0.002;           # Transition length scale
w = window_weight(xs, lims, α)

resolution = (700, 400); fontsize=25;
f = Figure(;resolution, fontsize)
ax = Axis(f[1,1], xlabel=L&quot;x_2&quot;, ylabel=L&quot;w&quot;)
plot!(xs[2, :], w)

f</code></pre><p><img src="../kernel-6.png" alt/></p><p>The above plot shows how the weighting applys to the vertical component. We see we are applying our boundary conditions at the top and bottom, but not in the interior. Now, we have enough information to call <code>kernel_eigs</code> to find an approximately invariant function. It does this by minimizing the following Rayleigh quotient:</p><p class="math-container">\[\lambda = \min_c \frac{ E_{\mathrm{Inv}} + E_{\mathrm{bd}} + E_{\mathrm{K}} }{E_{L^2}},\]</p><p>where</p><p class="math-container">\[E_{\mathrm{Inv}} = \sum_{n = 1}^N (h(y_{2n-1}) - h(y_{2n}))^2 = \sum_{n = 1}^N (h(x_n) - h(F(x_n)))^2\]</p><p>is an energy that forces <span>$h$</span> to be approximately invariant,</p><p class="math-container">\[E_{\mathrm{bd}} = \sum_{n=1}^{2N} w_{\mathrm{bd}}(y_n) h(y_n)^2\]</p><p>is the a penalty on nonzero boundary conditions,</p><p class="math-container">\[E_{\mathrm{K}} = \sum_{n, m = 1}^{2N} K(y_n, y_m) c_n c_m\]</p><p>is a kernel norm encouraging smooth solutions, and</p><p class="math-container">\[E_{L^2} = \sum_{n = 1}^{2N} h(y_n)^2\]</p><p>is the <span>$L^2$</span> norm of the function. We note that the eigenvalue problem is useful to get a nonzero solution (simply minimizing the numerator would give <span>$h = 0$</span> regardless of the map, a decidedly unhelpful function).</p><p>We can see an output approximately invariant function in the following block:</p><pre><code class="language-julia hljs">ϵ = 1e-8 # Weight of regularization. Should be small and nonzero
nev = 1  # Number of eigenvalues/eigenvectors to find
σ = 0.25 # Length scale of the kernel
kernel = :FourierSE # Product kernel that is periodic sine squared exponential in x and squared exponential in y

λs, vs, k = kernel_eigs(xs, ϵ, nev, σ, w; kernel)
println(&quot;The returned eigenvalue is λ = $(λs[1])&quot;)
f, f_grid = plot_on_grid(0:0.01:1, 0:0.01:1, k; levels=30,
                         resolution=(700, 600), xlabel=&quot;x&quot;, ylabel=&quot;y&quot;,
                         title=&quot;Approximately Invariant Eigenfunction&quot;)
f</code></pre><p><img src="../kernel-8.png" alt/></p><p>Qualitatively, we see the contours of the label function matches the Poincare plot well. Additionally, the value of <span>$\lambda$</span> tells us that <span>$E_{\mathrm{Inv}} \ll E_{L^2}$</span>, which is the discretization of our definition of an approximately invariant function.</p><p>We can find such a plot without an eigenvalue solve as well using a boundary value problem. For this, we require a boundary value function <span>$h_{\mathrm{bd}} : \Omega \to \mathbb{R}$</span>. Given this, the boundary value problem is phrased as</p><p class="math-container">\[R = \min_c (E_{\mathrm{Inv}} + E_{\mathrm{bd,h}} + \epsilon E_{\mathrm{K}}),\]</p><p>where</p><p class="math-container">\[E_{\mathrm{bd, h}} = \sum_{n=1}^{2N} w_{\mathrm{bd}}(y_n) (h(y_n) - h_{\mathrm{bd}}(y_n))^2\]</p><p>is the new boundary condition energy. The boundary values give a different method by which the label function is forced to be nonzero. Typically, the boundary value problem is useful when you want to know if circles foliate a certain annulus.</p><p>We can apply this method using the function <code>kernel_bvp</code>:</p><pre><code class="language-julia hljs">hbd = [xi[2] &gt; 0.5 ? 1. : -1. for xi = eachcol(xs)]
k, R, E_bd, E_inv, E_K = kernel_bvp(xs, ϵ, σ, w, hbd; kernel)
hs = evaluate(k, xs)
println(&quot;R     = $R,
E_bd  = $(E_bd),
E_inv = $(E_inv),
E_K   = $(E_K),
E_L2  = $(hs&#39;*hs)&quot;)
f, f_grid = plot_on_grid(0:0.01:1, 0:0.01:1, k; levels=30,
                         resolution=(700, 600), xlabel=&quot;x&quot;, ylabel=&quot;y&quot;,
                         title=&quot;Approximately Invariant BVP&quot;)
f</code></pre><p><img src="../kernel-10.png" alt/></p><p>Again, we see a very similar invariant function, with <span>$E_{\mathrm{Inv}} \ll E_{L^2}$</span>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../extrapolation/extrapolation/">« Birkhoff Extrapolation</a><a class="docs-footer-nextpage" href="../../../lib/Documentation/">Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 29 August 2023 20:00">Tuesday 29 August 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
