<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · SymplecticMapTools</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SymplecticMapTools</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SymplecticMapTools.jl</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/birkhoff_averaging/birkhoff_averaging/">Birkhoff Averages</a></li><li><a class="tocitem" href="../../examples/extrapolation/extrapolation/">Birkhoff Extrapolation</a></li><li><a class="tocitem" href="../../examples/kernel/kernel/">Approximately Invariant Kernel Functions</a></li></ul></li><li class="is-active"><a class="tocitem" href>Documentation</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Periodic-Orbits"><span>Periodic Orbits</span></a></li><li><a class="tocitem" href="#Invariant-Circles"><span>Invariant Circles</span></a></li><li><a class="tocitem" href="#Fourier-Circles"><span>Fourier Circles</span></a></li><li><a class="tocitem" href="#Connecting-Orbits"><span>Connecting Orbits</span></a></li><li><a class="tocitem" href="#Kernel-Labels"><span>Kernel Labels</span></a></li><li><a class="tocitem" href="#Continued-Fractions"><span>Continued Fractions</span></a></li><li><a class="tocitem" href="#Birkhoff-Extrapolation"><span>Birkhoff Extrapolation</span></a></li><li><a class="tocitem" href="#Example-Maps"><span>Example Maps</span></a></li><li><a class="tocitem" href="#Plotting-Routines:-Plots"><span>Plotting Routines: Plots</span></a></li><li><a class="tocitem" href="#Plotting-Routines:-CairoMakie"><span>Plotting Routines: CairoMakie</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/main/docs/src/lib/Documentation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h1><p>Documentation for SymplecticMapTools.jl</p><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Documentation">Documentation</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li><li><a href="#Periodic-Orbits">Periodic Orbits</a></li><li><a href="#Invariant-Circles">Invariant Circles</a></li><li><a href="#Fourier-Circles">Fourier Circles</a></li><li><a href="#Connecting-Orbits">Connecting Orbits</a></li><li><a href="#Kernel-Labels">Kernel Labels</a></li><li><a href="#Continued-Fractions">Continued Fractions</a></li><li><a href="#Birkhoff-Extrapolation">Birkhoff Extrapolation</a></li><li><a href="#Example-Maps">Example Maps</a></li><li><a href="#Plotting-Routines:-Plots">Plotting Routines: Plots</a></li><li><a href="#Plotting-Routines:-CairoMakie">Plotting Routines: CairoMakie</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#SymplecticMapTools.ConnectingOrbit"><code>SymplecticMapTools.ConnectingOrbit</code></a></li><li><a href="#SymplecticMapTools.ContFrac"><code>SymplecticMapTools.ContFrac</code></a></li><li><a href="#SymplecticMapTools.FourierCircle"><code>SymplecticMapTools.FourierCircle</code></a></li><li><a href="#SymplecticMapTools.InvariantCircle"><code>SymplecticMapTools.InvariantCircle</code></a></li><li><a href="#SymplecticMapTools.KernelLabel"><code>SymplecticMapTools.KernelLabel</code></a></li><li><a href="#Base.getindex-Tuple{ConnectingOrbit, Integer, Integer}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{FourierCircle, Integer, Integer}"><code>Base.getindex</code></a></li><li><a href="#Base.length-Tuple{FourierCircle}"><code>Base.length</code></a></li><li><a href="#Base.setindex!-Tuple{ConnectingOrbit, AbstractArray, Integer, Integer}"><code>Base.setindex!</code></a></li><li><a href="#Base.setindex!-Tuple{FourierCircle, AbstractArray, Integer, Integer}"><code>Base.setindex!</code></a></li><li><a href="#MakieCore.lines!-Tuple{Any, InvariantCircle}"><code>MakieCore.lines!</code></a></li><li><a href="#RecipesBase.plot-Tuple{ConnectingOrbit}"><code>RecipesBase.plot</code></a></li><li><a href="#RecipesBase.plot-Tuple{InvariantCircle}"><code>RecipesBase.plot</code></a></li><li><a href="#RecipesBase.plot!-Tuple{Plots.Plot, InvariantCircle}"><code>RecipesBase.plot!</code></a></li><li><a href="#RecipesBase.plot!-Tuple{Plots.Plot, ConnectingOrbit}"><code>RecipesBase.plot!</code></a></li><li><a href="#SymplecticMapTools.BFGS_periodic-Tuple{Function, AbstractVector, Integer}"><code>SymplecticMapTools.BFGS_periodic</code></a></li><li><a href="#SymplecticMapTools.adaptive_birkhoff_extrapolation"><code>SymplecticMapTools.adaptive_birkhoff_extrapolation</code></a></li><li><a href="#SymplecticMapTools.area-Tuple{ConnectingOrbit}"><code>SymplecticMapTools.area</code></a></li><li><a href="#SymplecticMapTools.area"><code>SymplecticMapTools.area</code></a></li><li><a href="#SymplecticMapTools.average_radius-Tuple{FourierCircle}"><code>SymplecticMapTools.average_radius</code></a></li><li><a href="#SymplecticMapTools.big_cont_frac_eval"><code>SymplecticMapTools.big_cont_frac_eval</code></a></li><li><a href="#SymplecticMapTools.big_denoms"><code>SymplecticMapTools.big_denoms</code></a></li><li><a href="#SymplecticMapTools.big_partial_frac"><code>SymplecticMapTools.big_partial_frac</code></a></li><li><a href="#SymplecticMapTools.birkhoff_extrapolation"><code>SymplecticMapTools.birkhoff_extrapolation</code></a></li><li><a href="#SymplecticMapTools.circle_linear!"><code>SymplecticMapTools.circle_linear!</code></a></li><li><a href="#SymplecticMapTools.denoms"><code>SymplecticMapTools.denoms</code></a></li><li><a href="#SymplecticMapTools.deriv-Tuple{FourierCircle}"><code>SymplecticMapTools.deriv</code></a></li><li><a href="#SymplecticMapTools.deval-Tuple{InvariantCircle, Number}"><code>SymplecticMapTools.deval</code></a></li><li><a href="#SymplecticMapTools.deval-Tuple{FourierCircle, AbstractVector}"><code>SymplecticMapTools.deval</code></a></li><li><a href="#SymplecticMapTools.deval-Tuple{ConnectingOrbit, Number}"><code>SymplecticMapTools.deval</code></a></li><li><a href="#SymplecticMapTools.doubling_birkhoff_average"><code>SymplecticMapTools.doubling_birkhoff_average</code></a></li><li><a href="#SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, Number}"><code>SymplecticMapTools.evaluate</code></a></li><li><a href="#SymplecticMapTools.evaluate-Tuple{KernelLabel, AbstractArray}"><code>SymplecticMapTools.evaluate</code></a></li><li><a href="#SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, AbstractArray}"><code>SymplecticMapTools.evaluate</code></a></li><li><a href="#SymplecticMapTools.evaluate-Tuple{InvariantCircle, Number}"><code>SymplecticMapTools.evaluate</code></a></li><li><a href="#SymplecticMapTools.evaluate-Tuple{FourierCircle, AbstractVector}"><code>SymplecticMapTools.evaluate</code></a></li><li><a href="#SymplecticMapTools.evaluate-Tuple{ContFrac}"><code>SymplecticMapTools.evaluate</code></a></li><li><a href="#SymplecticMapTools.get_Am"><code>SymplecticMapTools.get_Am</code></a></li><li><a href="#SymplecticMapTools.get_Na-Tuple{FourierCircle}"><code>SymplecticMapTools.get_Na</code></a></li><li><a href="#SymplecticMapTools.get_Na-Tuple{ConnectingOrbit}"><code>SymplecticMapTools.get_Na</code></a></li><li><a href="#SymplecticMapTools.get_a0"><code>SymplecticMapTools.get_a0</code></a></li><li><a href="#SymplecticMapTools.get_am-Tuple{ConnectingOrbit, Integer}"><code>SymplecticMapTools.get_am</code></a></li><li><a href="#SymplecticMapTools.get_circle_info"><code>SymplecticMapTools.get_circle_info</code></a></li><li><a href="#SymplecticMapTools.get_circle_residual"><code>SymplecticMapTools.get_circle_residual</code></a></li><li><a href="#SymplecticMapTools.get_energies"><code>SymplecticMapTools.get_energies</code></a></li><li><a href="#SymplecticMapTools.get_matrix-Tuple{KernelLabel, AbstractArray}"><code>SymplecticMapTools.get_matrix</code></a></li><li><a href="#SymplecticMapTools.get_p-Tuple{FourierCircle}"><code>SymplecticMapTools.get_p</code></a></li><li><a href="#SymplecticMapTools.get_p-Tuple{ConnectingOrbit}"><code>SymplecticMapTools.get_p</code></a></li><li><a href="#SymplecticMapTools.get_sum_ave"><code>SymplecticMapTools.get_sum_ave</code></a></li><li><a href="#SymplecticMapTools.get_τ"><code>SymplecticMapTools.get_τ</code></a></li><li><a href="#SymplecticMapTools.gn_circle"><code>SymplecticMapTools.gn_circle</code></a></li><li><a href="#SymplecticMapTools.gn_connecting!"><code>SymplecticMapTools.gn_connecting!</code></a></li><li><a href="#SymplecticMapTools.kernel_birkhoff"><code>SymplecticMapTools.kernel_birkhoff</code></a></li><li><a href="#SymplecticMapTools.kernel_bvp"><code>SymplecticMapTools.kernel_bvp</code></a></li><li><a href="#SymplecticMapTools.kernel_eigs"><code>SymplecticMapTools.kernel_eigs</code></a></li><li><a href="#SymplecticMapTools.kernel_sample_F"><code>SymplecticMapTools.kernel_sample_F</code></a></li><li><a href="#SymplecticMapTools.linear_initial_connecting_orbit"><code>SymplecticMapTools.linear_initial_connecting_orbit</code></a></li><li><a href="#SymplecticMapTools.lines_periodic!-Tuple{Any, InvariantCircle, Function}"><code>SymplecticMapTools.lines_periodic!</code></a></li><li><a href="#SymplecticMapTools.newton_periodic-Tuple{Function, AbstractVector, Integer}"><code>SymplecticMapTools.newton_periodic</code></a></li><li><a href="#SymplecticMapTools.parametric_plot"><code>SymplecticMapTools.parametric_plot</code></a></li><li><a href="#SymplecticMapTools.partial_frac"><code>SymplecticMapTools.partial_frac</code></a></li><li><a href="#SymplecticMapTools.plot_on_grid-Tuple{AbstractVector, AbstractVector, KernelLabel}"><code>SymplecticMapTools.plot_on_grid</code></a></li><li><a href="#SymplecticMapTools.poincare_plot-Tuple{AbstractVector, AbstractVector, Function, Integer, Integer}"><code>SymplecticMapTools.poincare_plot</code></a></li><li><a href="#SymplecticMapTools.polar_map"><code>SymplecticMapTools.polar_map</code></a></li><li><a href="#SymplecticMapTools.rectangular_window_weight"><code>SymplecticMapTools.rectangular_window_weight</code></a></li><li><a href="#SymplecticMapTools.set_Am!"><code>SymplecticMapTools.set_Am!</code></a></li><li><a href="#SymplecticMapTools.set_a0!"><code>SymplecticMapTools.set_a0!</code></a></li><li><a href="#SymplecticMapTools.set_am!-Tuple{ConnectingOrbit, Integer, AbstractArray}"><code>SymplecticMapTools.set_am!</code></a></li><li><a href="#SymplecticMapTools.set_τ!"><code>SymplecticMapTools.set_τ!</code></a></li><li><a href="#SymplecticMapTools.shifted_eval"><code>SymplecticMapTools.shifted_eval</code></a></li><li><a href="#SymplecticMapTools.standard_map_F"><code>SymplecticMapTools.standard_map_F</code></a></li><li><a href="#SymplecticMapTools.standard_map_FJ"><code>SymplecticMapTools.standard_map_FJ</code></a></li><li><a href="#SymplecticMapTools.sum_stats"><code>SymplecticMapTools.sum_stats</code></a></li><li><a href="#SymplecticMapTools.vector_mpe_backslash"><code>SymplecticMapTools.vector_mpe_backslash</code></a></li><li><a href="#SymplecticMapTools.vector_mpe_iterative"><code>SymplecticMapTools.vector_mpe_iterative</code></a></li><li><a href="#SymplecticMapTools.wba_weight"><code>SymplecticMapTools.wba_weight</code></a></li><li><a href="#SymplecticMapTools.weighted_birkhoff_average"><code>SymplecticMapTools.weighted_birkhoff_average</code></a></li><li><a href="#SymplecticMapTools.window_weight"><code>SymplecticMapTools.window_weight</code></a></li></ul><h2 id="Periodic-Orbits"><a class="docs-heading-anchor" href="#Periodic-Orbits">Periodic Orbits</a><a id="Periodic-Orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-Orbits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.BFGS_periodic-Tuple{Function, AbstractVector, Integer}" href="#SymplecticMapTools.BFGS_periodic-Tuple{Function, AbstractVector, Integer}"><code>SymplecticMapTools.BFGS_periodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">BFGS_periodic(FJ::Function, x::AbstractVector, q::Integer;
              maxiter::Integer=50)</code></pre><p>Find a periodic orbit using BFGS from the Optim package.</p><p>Arguments:</p><ul><li><code>FJ</code>: A function that returns the map and its derivative <code>F, dFdx = FJ(x)</code></li><li><code>x</code>: An initial point to find the orbit from</li><li><code>q</code>: The period of the orbit</li><li><code>maxiter=50</code>: The maximum number of optimization steps allows</li></ul><p>Output:</p><ul><li><code>xs</code>: A periodic trajectory of length <code>d</code></li><li><code>res</code>: An Optim return object, (can check convergence with <code>Optim.converged(res)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/PeriodicOrbits/PeriodicOrbits.jl#L42-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.newton_periodic-Tuple{Function, AbstractVector, Integer}" href="#SymplecticMapTools.newton_periodic-Tuple{Function, AbstractVector, Integer}"><code>SymplecticMapTools.newton_periodic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">newton_periodic(FJ::Function, x::AbstractVector, q::Integer;
                maxiter::Integer=50, rtol::Number=1e-8, verbose::Bool=false)</code></pre><p>Find a periodic orbit using Newton&#39;s method with line search</p><p>Arguments:</p><ul><li><code>FJ</code>: A function that returns the map and its derivative <code>F, dFdx = FJ(x)</code></li><li><code>x</code>: An initial point to find the orbit from</li><li><code>q</code>: The period of the orbit</li><li><code>maxiter=50</code>: The maximum number of optimization steps allows</li><li><code>rtol=1e-8</code>: The residual tolerance required</li><li><code>verbose=false</code>: If true, outputs information about convergence</li></ul><p>Output:</p><ul><li><code>xs</code>: A periodic trajectory of length <code>d</code></li><li><code>converged</code>: A flag that indicates whether the orbit converged in <code>maxiter</code> steps</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/PeriodicOrbits/PeriodicOrbits.jl#L92-L110">source</a></section></article><h2 id="Invariant-Circles"><a class="docs-heading-anchor" href="#Invariant-Circles">Invariant Circles</a><a id="Invariant-Circles-1"></a><a class="docs-heading-anchor-permalink" href="#Invariant-Circles" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.InvariantCircle" href="#SymplecticMapTools.InvariantCircle"><code>SymplecticMapTools.InvariantCircle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type InvariantCircle</code></pre><p>An abstract type representing a chain of invariant circles zᵢ where zᵢ₊₁ = F(zᵢ) for i&lt;=p and z₀ = F(zₚ₋₁). The main implementation of this type of FourierCircle, but other potential implementations of circles could exist.</p><p>Implementations should have the following functions for immediate portability:</p><p>Basic stuff</p><ul><li>Initializer   <code>InvariantCircleImplementation(stuff)</code></li><li>Similar   <code>Base.similar(z::InvariantCircle)</code></li></ul><p>Getters and Setters<br/> - Get number of unknown variables per circle     <code>get_N(z::InvariantCircle)</code><br/> - Get period of circle     <code>get_p(z::InvariantCircle)</code></p><ul><li>Get parameters (except τ)  <code>get_a(z::InvariantCircle)</code></li><li>Set parameters (except τ)  <code>set_a!(z::InvariantCircle, a::AbstractArray)</code></li><li>Get rotation number τ in [0,2π)  <code>get_τ(z::InvariantCircle)</code></li><li>Set τ  <code>set_τ!(z::InvariantCircle, τ::Number)</code></li></ul><p>Evaluation related routines</p><ul><li>Evaluate the circle (see <code>(z::InvariantCircle)(θ, i_circle)</code>)   <code>evaluate(z::InvariantCircle, θ::AbstractVector; i_circle::Integer=1)</code></li><li>Evaluate the derivative of the circle w.r.t. θ   <code>deval(z::InvariantCircle, θ::AbstractVector; i_circle::Integer=1)</code></li><li>Get a basis Φ for z evaluated at Nθ equispaced points (requires linearity)   <code>get_Φ(z::InvariantCircle, Nθ::Integer; τ::Number=0.0)</code></li><li>Evaluate the invariant circle on Φ   <code>function grid_eval!(x::AbstractArray, z::InvariantCircle, Φ::AbstractArray;</code>                       <code>i_circle=0)</code></li><li>Evaluate the derivative of the invariant circle on Φ   <code>grid_deval!(dx::AbstractArray, z::InvariantCircle, Φ::AbstractArray;</code>               <code>i_circle=0)</code></li></ul><p>Constraints (for Newton iteration)</p><ul><li>Constrain the value at 0   <code>fixed_θ0_constraint(z::InvariantCircle)</code></li></ul><p>Other routines (useful for continuation)</p><ul><li>Get average radius   <code>LinearAlgebra.average_radius(z::InvariantCircle)</code></li><li>Get the area of the invariant circle   <code>area(z::InvariantCircle; i_circle=1, Ns = 100)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/InvariantCircles.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.evaluate-Tuple{InvariantCircle, Number}" href="#SymplecticMapTools.evaluate-Tuple{InvariantCircle, Number}"><code>SymplecticMapTools.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(z::InvariantCircle, θ::Number; i_circle::Integer=1)</code></pre><p>Evaluate the <code>i_circle</code>th circle in <code>z</code> at the point <code>θ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/InvariantCircles.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.deval-Tuple{InvariantCircle, Number}" href="#SymplecticMapTools.deval-Tuple{InvariantCircle, Number}"><code>SymplecticMapTools.deval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deval(z::InvariantCircle, θ::Number; i_circle::Integer=1)</code></pre><p>Evaluate the derivative of the <code>i_circle</code>th circle in <code>z</code> at the point <code>θ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/InvariantCircles.jl#L66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.shifted_eval" href="#SymplecticMapTools.shifted_eval"><code>SymplecticMapTools.shifted_eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shifted_eval(z::InvariantCircle, θ::AbstractVector; i_circle::Integer=1)</code></pre><p>Evaluate the <code>i_circle</code>th circle in <code>z</code> at the point <code>θ</code>, shifted by <code>τ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/InvariantCircles.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_circle_residual" href="#SymplecticMapTools.get_circle_residual"><code>SymplecticMapTools.get_circle_residual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_circle_residual(F::Function, z::InvariantCircle, Nθ::Integer)</code></pre><p>Get the KAM-like residual of a chain of p invariant circles.<br/>&gt;   Rᵢ₁ = z₁(θᵢ+τ) - F(z_p(θᵢ))<br/>&gt;   Rᵢⱼ = zⱼ(θᵢ) - F(zⱼ₋₁(θᵢ)) for 2&lt;=j&lt;=p</p><p>Arguments:</p><ul><li><code>F</code>: Symplectic map</li><li><code>z</code>: Invariant circle</li><li><code>Nθ</code>: Number of θ points where the residual is taken</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/InvariantCircles.jl#L304-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.gn_circle" href="#SymplecticMapTools.gn_circle"><code>SymplecticMapTools.gn_circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gn_circle(FJ::Function, z::InvariantCircle, Nθ::Integer;
          maxiter::Integer=10, rtol::Number=1e-8, verbose::Bool=false,
          monitor::Function=(z, rnorm) -&gt; nothing,
          constraint::Function=fixed_θ0_constraint, λ::Number=0)</code></pre><p>Find an invariant circle using Gauss-Newton with linesearch. Implemented with dense linear algebra (no FFTs yet). Returns the number of iterations taken to converge. If an evaluation fails, returns <code>-1</code>. If the routine fails to converge, returns <code>-2</code></p><p>Arguments:</p><ul><li><code>z::InvariantCircle</code>: An initial connecting orbit guess, see <code>linear_initial_connecting_orbit</code></li><li><code>FJ::Function</code>: Function defined on R² with signature <code>F(x), J(x) = FJ(x)</code> where <code>F</code> is the symplectic map and <code>J = dF/dx</code></li><li><code>Nθ</code>: Number of quadrature nodes for the least squares</li><li><code>maxiter = 10</code>: Maximum number of Gauss Newton steps</li><li><code>rtol = 1e-8</code>: Stopping tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/InvariantCircles.jl#L353-L372">source</a></section></article><h2 id="Fourier-Circles"><a class="docs-heading-anchor" href="#Fourier-Circles">Fourier Circles</a><a id="Fourier-Circles-1"></a><a class="docs-heading-anchor-permalink" href="#Fourier-Circles" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.FourierCircle" href="#SymplecticMapTools.FourierCircle"><code>SymplecticMapTools.FourierCircle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FourierCircle &lt;: InvariantCircle</code></pre><p>Constructors:</p><ul><li><code>FourierCircle(Na::Integer; a::AbstractArray=[], τ::Number=0., p::Integer=1)</code></li></ul><p>Fourier invariant circle data structure (see InvariantCircle), used to compute a circle z that is invariant of a map Fᵖ(z), where p is the period. This is done by storing all of the circles Fⁱ(z) for 0&lt;=i&lt;p. The circles are stored as Fourier series, i.e.    z(θ) = a₀ + ∑₁ᴺᵃ Aⱼ [cos(jθ), sin(jθ)]ᵀ The coefficients of the invariant circle can be accessed and set in chunks via array indexing. That is,   You can get and set a₀ of the ith circle using <code>z[0, i]</code>   You can get and set Aⱼ of the ith circle using <code>z[j, i]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_Na-Tuple{FourierCircle}" href="#SymplecticMapTools.get_Na-Tuple{FourierCircle}"><code>SymplecticMapTools.get_Na</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Na(z::FourierCircle)</code></pre><p>Get number of Fourier modes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_p-Tuple{FourierCircle}" href="#SymplecticMapTools.get_p-Tuple{FourierCircle}"><code>SymplecticMapTools.get_p</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>get_p(z::FourierCircle)</code></p><p>Get number of islands</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{FourierCircle}" href="#Base.length-Tuple{FourierCircle}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><p><code>Base.length(z::FourierCircle)</code></p><p>Get total number of parameters, excluding τ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_a0" href="#SymplecticMapTools.get_a0"><code>SymplecticMapTools.get_a0</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_a0(z::FourierCircle; i_circle::Integer=1)</code></pre><p>Get constant term of Fourier series of the <code>i_circle</code>th circle in island chain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.set_a0!" href="#SymplecticMapTools.set_a0!"><code>SymplecticMapTools.set_a0!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_a0!(z::FourierCircle, a0::AbstractArray; i_circle::Integer=1)</code></pre><p>Set constant term of Fourier series of the <code>i_circle</code>th circle in island chain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_Am" href="#SymplecticMapTools.get_Am"><code>SymplecticMapTools.get_Am</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_Am(z::FourierCircle, m::Integer; i_circle::Integer=1)</code></pre><p>Get <code>m</code>th Fourier coefficients of the <code>i_circle</code>th circle in island chain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L91-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.set_Am!" href="#SymplecticMapTools.set_Am!"><code>SymplecticMapTools.set_Am!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_Am!(z::FourierCircle, m::Integer, a::AbstractArray; i_circle::Integer=1)</code></pre><p>Set <code>m</code>th Fourier coefficients of the <code>i_circle</code>th circle in island chain</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{FourierCircle, Integer, Integer}" href="#Base.getindex-Tuple{FourierCircle, Integer, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(z::FourierCircle, i_A::Integer, i_circle::Integer)</code></pre><p>Get the coefficients of z. <code>z[0, i_circle]</code> gets the constant term. <code>z[i_A, i_circle]</code> gets higher coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{FourierCircle, AbstractArray, Integer, Integer}" href="#Base.setindex!-Tuple{FourierCircle, AbstractArray, Integer, Integer}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.setindex!(z::FourierCircle, X::AbstractArray, i_A::Integer,
               i_circle::Integer)</code></pre><p>Set the coefficients of z. <code>z[0, i_circle]</code> sets the constant term. <code>z[i_A, i_circle]</code> sets higher coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_τ" href="#SymplecticMapTools.get_τ"><code>SymplecticMapTools.get_τ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_τ(z::FourierCircle)</code></pre><p>Get the rotation number (the circle is 2π periodic)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.set_τ!" href="#SymplecticMapTools.set_τ!"><code>SymplecticMapTools.set_τ!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_τ!(z::FourierCircle, τ::Number)</code></pre><p>Set the rotation number (the circle is 2π periodic)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.average_radius-Tuple{FourierCircle}" href="#SymplecticMapTools.average_radius-Tuple{FourierCircle}"><code>SymplecticMapTools.average_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">average_radius(z::FourierCircle)</code></pre><p>Norm defined as the L2 norm of the radius, i.e. ‖z‖² = 1/2πp ∫ ||z(θ) - a₀||^2 dθ      = 1/2p ∑ₖ Tr(AₖᵀAₖ) If <code>i_circle = 0</code>, takes the norm over all circles. If <code>i_circle != 0</code>, finds the average radius of a single circle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L172-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.evaluate-Tuple{FourierCircle, AbstractVector}" href="#SymplecticMapTools.evaluate-Tuple{FourierCircle, AbstractVector}"><code>SymplecticMapTools.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(z::FourierCircle, θ::AbstractVector{T}; i_circle::Integer=1) where {T}</code></pre><p>Evaluate the <code>i_circle</code>th circle in the chain at a vector of points θ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L191-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.deval-Tuple{FourierCircle, AbstractVector}" href="#SymplecticMapTools.deval-Tuple{FourierCircle, AbstractVector}"><code>SymplecticMapTools.deval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deval(z::FourierCircle, θ::AbstractVector; i_circle::Integer=1)</code></pre><p>Evaluate the derivative of the <code>i_circle</code>th circle in the chain at a vector of points <code>θ</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L214-L219">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.deriv-Tuple{FourierCircle}" href="#SymplecticMapTools.deriv-Tuple{FourierCircle}"><code>SymplecticMapTools.deriv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deriv(z::FourierCircle)</code></pre><p>Return the derivative of the FourierCircle, wrapped in a circle object</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.area" href="#SymplecticMapTools.area"><code>SymplecticMapTools.area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area(z::FourierCircle; i_circle=1)</code></pre><p>Get the area of the circle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L314-L318">source</a></section><section><div><pre><code class="language-julia hljs">area(c::ConnectingOrbit; origin::AbstractArray=[0.0,0.0],
     i_p::Integer=1, rtol=1e-8)</code></pre><p>Get the &quot;area&quot; of a connecting orbit ∫₋₁¹ (x dy/ds - y dy/ds) ds</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.circle_linear!" href="#SymplecticMapTools.circle_linear!"><code>SymplecticMapTools.circle_linear!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">circle_linear!(z::FourierCircle, FJ::Function, x::AbstractArray, h::Number)</code></pre><p>Fill <code>z</code>&#39;s Fourier coefficients using a linearization about a stable periodic orbit. Useful for seeding continuation.</p><p>Arguments:</p><ul><li><code>z</code>: An invariant circle</li><li><code>FJ</code>: A function that returns the map and its derivative <code>F, dFdx = FJ(x)</code></li><li><code>x</code>: A periodic orbit of <code>F</code></li><li><code>h</code>: The average radius of the first linearized invariant circle</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/FourierCircle.jl#L379-L390">source</a></section></article><h2 id="Connecting-Orbits"><a class="docs-heading-anchor" href="#Connecting-Orbits">Connecting Orbits</a><a id="Connecting-Orbits-1"></a><a class="docs-heading-anchor-permalink" href="#Connecting-Orbits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.ConnectingOrbit" href="#SymplecticMapTools.ConnectingOrbit"><code>SymplecticMapTools.ConnectingOrbit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConnectingOrbit(Na::Integer, p::Integer)</code></pre><p>Initialize a connecting orbit consisting of <code>p</code> segments cⱼ : [0,1] -&gt; R². The endpoints cⱼ(0) and cⱼ(1) are both hyperbolic perodic orbits. The connecting orbits connect these, acting as the outer boundary of an island. The connecting orbits are parameterized by Chebyshev polynomials of degree <code>Na</code>.</p><p>See <code>linear_initial_connecting_orbit</code> and <code>gn_connecting!</code> for functions to initialize and compute a connecting orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L2-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_Na-Tuple{ConnectingOrbit}" href="#SymplecticMapTools.get_Na-Tuple{ConnectingOrbit}"><code>SymplecticMapTools.get_Na</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_Na(c::ConnectingOrbit)</code></pre><p>Get the polynomial degree of the connecting orbit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_p-Tuple{ConnectingOrbit}" href="#SymplecticMapTools.get_p-Tuple{ConnectingOrbit}"><code>SymplecticMapTools.get_p</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_p(c::ConnectingOrbit)</code></pre><p>Get the period of the connecting orbit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_am-Tuple{ConnectingOrbit, Integer}" href="#SymplecticMapTools.get_am-Tuple{ConnectingOrbit, Integer}"><code>SymplecticMapTools.get_am</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_am(c::ConnectingOrbit, m::Integer; i_p::Integer=1)</code></pre><p>Get the <code>m</code>th Chebyshev coefficient of the <code>i_p</code>th connecting orbit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L58-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.set_am!-Tuple{ConnectingOrbit, Integer, AbstractArray}" href="#SymplecticMapTools.set_am!-Tuple{ConnectingOrbit, Integer, AbstractArray}"><code>SymplecticMapTools.set_am!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_am!(c::ConnectingOrbit, m::Integer, am::AbstractArray; i_p::Integer=1)</code></pre><p>Set the <code>m</code>th Chebyshev coefficient of the <code>i_p</code>th connecting orbit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{ConnectingOrbit, Integer, Integer}" href="#Base.getindex-Tuple{ConnectingOrbit, Integer, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.getindex(c::ConnectingOrbit, i_A::Integer, i_p::Integer)</code></pre><p>Wrapper for <code>get_am</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{ConnectingOrbit, AbstractArray, Integer, Integer}" href="#Base.setindex!-Tuple{ConnectingOrbit, AbstractArray, Integer, Integer}"><code>Base.setindex!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Base.setindex!(c::ConnectingOrbit, X::AbstractArray, i_A::Integer, i_p::Integer)</code></pre><p>Wrapper for <code>set_am!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, AbstractArray}" href="#SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, AbstractArray}"><code>SymplecticMapTools.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(c::ConnectingOrbit, x::AbstractArray; i_p::Integer=1)</code></pre><p>Evaluate the <code>i_p</code>th connecting orbit at a set of points <code>x[j]</code> in [0,1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, Number}" href="#SymplecticMapTools.evaluate-Tuple{ConnectingOrbit, Number}"><code>SymplecticMapTools.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(c::ConnectingOrbit, x::Number; i_p::Integer=1)</code></pre><p>Evaluate the <code>i_p</code>th connecting orbit at a point <code>x</code> in [0,1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.deval-Tuple{ConnectingOrbit, Number}" href="#SymplecticMapTools.deval-Tuple{ConnectingOrbit, Number}"><code>SymplecticMapTools.deval</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deval(c::ConnectingOrbit, x::Number; i_p::Integer=1)</code></pre><p>Evaluate the derivative of the <code>i_p</code>th connecting orbit at a point <code>x</code> in [0,1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L131-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.area-Tuple{ConnectingOrbit}" href="#SymplecticMapTools.area-Tuple{ConnectingOrbit}"><code>SymplecticMapTools.area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area(c::ConnectingOrbit; origin::AbstractArray=[0.0,0.0],
     i_p::Integer=1, rtol=1e-8)</code></pre><p>Get the &quot;area&quot; of a connecting orbit ∫₋₁¹ (x dy/ds - y dy/ds) ds</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L158-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.linear_initial_connecting_orbit" href="#SymplecticMapTools.linear_initial_connecting_orbit"><code>SymplecticMapTools.linear_initial_connecting_orbit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">linear_initial_connecting_orbit(x0, x1, Na::Integer)</code></pre><p>Initialize a ConnectingOrbit of degree <code>Na</code> using the two hyperbolic orbits <code>x0</code> and <code>x1</code> of the form <code>xn = [xn0, F(xn0), ..., F^(p-1)(xn0)]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L218-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.gn_connecting!" href="#SymplecticMapTools.gn_connecting!"><code>SymplecticMapTools.gn_connecting!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gn_connecting!(c::ConnectingOrbit, FJ::Function, ends::AbstractArray;
               Ns = 100, maxiters = 10, rtol = 1e-8, verbose=false)</code></pre><p>Find a connecting orbit using Gauss Newton with linesearch.</p><p>Arguments:</p><ul><li><code>c::ConnectingOrbit</code>: An initial connecting orbit guess, see <code>linear_initial_connecting_orbit</code></li><li><code>FJ::Function</code>: Function defined on R² with signature  <code>F(x), J(x) = FJ(x)</code> where <code>F</code> is the symplectic map and <code>J = dF/dx</code></li><li><code>ends::AbstractArray</code>: A 2p × 2 matrix containing the end periodic orbits <code>[x00, x10; F(x00), F(x10); ... ; F^(p-1)(x00), F^(p-1)(x10)]</code></li><li><code>Ns = 100</code>: Number of quadrature nodes for the least squares</li><li><code>maxiters = 10</code>: Maximum number of Gauss Newton steps</li><li><code>rtol = 1e-8</code>: Stopping tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/InvariantCircles/ConnectingOrbit.jl#L385-L401">source</a></section></article><h2 id="Kernel-Labels"><a class="docs-heading-anchor" href="#Kernel-Labels">Kernel Labels</a><a id="Kernel-Labels-1"></a><a class="docs-heading-anchor-permalink" href="#Kernel-Labels" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.KernelLabel" href="#SymplecticMapTools.KernelLabel"><code>SymplecticMapTools.KernelLabel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KernelLabel</code></pre><p>Constructors:</p><ul><li><code>KernelLabel(x::AbstractArray, c::AbstractVector, σ::Number;</code>               <code>kernel::Symbol=:SquaredExponential)</code></li><li><code>KernelLabel(x::AbstractArray, c::AbstractVector, σ::AbstractArray;</code>               <code>kernel::Symbol=:SquaredExponential)</code></li></ul><p>An approximately invariant kernel label function.</p><p>Constructor elements:</p><ul><li><code>x</code>: The <code>d</code> × <code>2N</code> array of interpolating points, where <code>x[:, n+N] = F(x[:, n])</code> for <code>n&lt;=N</code> and some symplectic map <code>F</code>.</li><li><code>c</code>: The length <code>2N</code> vector of coefficients of the kernel function</li><li><code>σ</code>: The length scale of the kernel (if a vector, length scale is different in different directions)</li><li><code>kernel</code>: The type of kernel used</li></ul><p>The current supported kernels are:</p><ul><li><code>:SquaredExponential</code>: The squared exponential kernel   K(x, y) = exp(-|x-y|²)</li><li><code>:InverseMultiquadric</code>: The β=1 Inverse Multiquadric kernel   K(x, y) = (1+|x-y|²)^(-1/2)</li><li><code>:FourierSE</code>: The Fourier × Cartesian squared exponential kernel   K(x, y) = exp(-sin²(x₁-y₁) - (x₂-y₂)²)</li><li><code>:Fourier</code>: The Fourier × Fourier squared exponential kernel   K(x, y) = exp(-sin²(x₁-y₁) - sin²(x₂-y₂))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/Kernels/kernels.jl#L23-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_matrix-Tuple{KernelLabel, AbstractArray}" href="#SymplecticMapTools.get_matrix-Tuple{KernelLabel, AbstractArray}"><code>SymplecticMapTools.get_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_matrix(k::KernelLabel, x::AbstractArray)</code></pre><p>Get the kernel matrix <code>K[i,j] = K(k.x[:,i], x[:,j])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/Kernels/kernels.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.evaluate-Tuple{KernelLabel, AbstractArray}" href="#SymplecticMapTools.evaluate-Tuple{KernelLabel, AbstractArray}"><code>SymplecticMapTools.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(k::KernelLabel, x::AbstractArray)</code></pre><p>Evaluate the kernel matrix at the columns of x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/Kernels/kernels.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.window_weight" href="#SymplecticMapTools.window_weight"><code>SymplecticMapTools.window_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">window_weight(xs::AbstractArray, lims::AbstractVector, α::Number;
                   ind::Integer=2)</code></pre><p>A simple boundary weighting function for <code>kernel_eigs</code> and <code>kernel_bvp</code>. Returns a weight that is approximately 1 outside of <code>lims</code> and 0 inside via the sum of two logistic functions.</p><p>Arguments:</p><ul><li><code>xs</code>: A <code>d</code> × <code>N</code> array of points, where <code>d</code> is the size of the phase space and <code>N</code> is the number of points.</li><li><code>lims</code>: A 2-vector giving the interval where the weight is approximately 0</li><li><code>α</code>: The length scale of the logistic functions (typically small relative to the size of the domain)</li><li><code>ind=2</code>: The index over which the window is applied. Defaults to <code>2</code> for maps on T×R (such as the standard map)</li></ul><p>Output:</p><ul><li><code>w</code>: A <code>N</code>-vector with the window weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/KernelLabel.jl#L39-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.rectangular_window_weight" href="#SymplecticMapTools.rectangular_window_weight"><code>SymplecticMapTools.rectangular_window_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rectangular_window_weight(xs::AbstractArray, xlims::AbstractVector,
                          ylims::AbstractVector, α::Number)</code></pre><p>A simple boundary weighting function for <code>kernel_eigs</code> and <code>kernel_bvp</code>. Returns a weight that is approximately 1 outside of <code>xlims</code> × <code>ylims</code> and 0 inside via the a function of logistic functions.</p><p>Arguments:</p><ul><li><code>xs</code>: A <code>d</code> × <code>N</code> array of points, where <code>d</code> is the size of the phase space and <code>N</code> is the number of points.</li><li><code>xlims</code> and <code>ylims</code>: 2-vectors giving the rectangle where the weight is approximately 0</li><li><code>α</code>: The length scale of the logistic functions (typically small relative to the size of the domain)</li></ul><p>Output:</p><ul><li><code>w</code>: A <code>N</code>-vector with the window weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/KernelLabel.jl#L66-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.kernel_sample_F" href="#SymplecticMapTools.kernel_sample_F"><code>SymplecticMapTools.kernel_sample_F</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kernel_sample_F(F::Function, N::Integer, xb::AbstractVector,
                yb::AbstractVector)</code></pre><p>Sobol sample <code>N</code> points in the rectangle <code>xb</code> × <code>yb</code>. Then, evaluate <code>F</code> at each point. Input can be used for <code>kernel_eigs</code> and <code>kernel_bvp</code></p><p>Arguments:</p><ul><li><code>F</code>: The symplectic map from the state space to itself</li><li><code>N</code>: The number of points to be sampled</li><li><code>xb</code> × <code>yb</code>: The 2-vector bounds of the rectangle to be sampled</li></ul><p>Output:</p><ul><li><code>xs</code>: A <code>2</code> × <code>2N</code> array of samples compatable with <code>kernel_eigs</code> and <code>kernel_bvp</code>, of the form <code>[x_1, F(x_1), x_2, F(x_2), ...]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/KernelLabel.jl#L7-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.kernel_eigs" href="#SymplecticMapTools.kernel_eigs"><code>SymplecticMapTools.kernel_eigs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kernel_eigs(xs::AbstractArray, ϵ::Number, nev::Integer, σ::Number,
            boundary_weights::Vector; kernel::Symbol=:SquaredExponential,
            zero_mean = false, check = 1)</code></pre><p>Solve the the invariant eigenvalue problem, given by the Rayleigh quotient<br/>&gt; <code>min_c (‖GKc‖² + ‖Kc‖²_bd + ϵ‖c‖²_k)/‖Kc‖²</code> <br/>where</p><ul><li><code>‖GKc‖²</code> is a norm penalizing invariance (and possible a non-zero mean)</li><li><code>‖Kc‖²_bd</code> is a norm penalizing boundary violation</li><li><code>‖c‖²_k</code> is the smoothing kernel norm</li><li><code>‖Kc‖²</code> is the ℓ² norm of the points</li></ul><p>The eigenvalue problem is solved via <code>Arpack.jl</code></p><p>Arguments:</p><ul><li><code>xs</code>: interpolation points of size d × 2N, where xs[:, N+1:2N] = F.(xs[:, 1:N])</li><li><code>ϵ</code>: Amount of regularization</li><li><code>nev</code>: Number of eigenvalues to find</li><li><code>σ</code>: Kernel width</li><li><code>boundary_weights</code>: Boundary weighting vector, should be positive and O(1) at points <code>x</code> where one wants |k(x)| &lt;&lt; 1</li><li><code>kernel</code>: Type of kernel to interpolate (see <code>KernelLabel</code>)</li><li><code>zero_mean = false</code>: Set to true to add a constraint that encourages <code>k</code> to have a zero mean. Useful when <code>xs</code> are sampled on an invariant set and boundary_weights=0</li><li><code>check = 1</code>: See <code>Arpack.eigs</code>. If 1, return all of the converged eigenvectors and eigenvalues. If 0, throw an error instead.</li></ul><p>Output:</p><ul><li><code>λs</code>: The eigenvalues</li><li><code>vs</code>: The eigenvectors</li><li><code>k</code>: The kernel label. Use <code>set_c!(k, vs[:,n])</code> to load the <code>n</code>th eigenvector into <code>k</code>. By default, <code>k</code> stores the lowest order eigenvector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/KernelLabel.jl#L93-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.kernel_bvp" href="#SymplecticMapTools.kernel_bvp"><code>SymplecticMapTools.kernel_bvp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kernel_bvp(xs::AbstractArray, ϵ::Number, σ::Number,
           boundary_weights::AbstractVector,
           boundary_values::AbstractVector;
           kernel::Symbol=:SquaredExponential, residuals::Bool=true)</code></pre><p>Solve the the invariant boundary value least-squares problem<br/>&gt; <code>min_c ‖GKc‖² + ‖Kc - h_{bd}‖²_bd + ϵ‖c‖²_k = R_inv + R_bd + R_eps</code><br/>where</p><ul><li><code>‖GKc‖²</code> is a norm penalizing invariance (and possible a non-zero mean)</li><li><code>‖Kc - h_{bd}‖²_bd</code> is a norm penalizing the function from violating the boundary condition</li><li><code>‖c‖²_k</code> is the smoothing kernel norm</li></ul><p>Arguments:</p><ul><li><code>xs</code>: interpolation points of size d × 2N, where xs[:, N+1:2N] = F.(xs[:, 1:N])</li><li><code>ϵ</code>: Amount of regularization</li><li><code>σ</code>: Kernel width</li><li><code>boundary_weights</code>: Length <code>2N</code> boundary weighting vector, should be positive and O(1) at points <code>x</code> where one wants |k(x)| &lt;&lt; 1</li><li><code>boundary_values</code>: Length <code>2N</code> boundary value vector, indicating the value the function should take at each point</li><li><code>kernel=:SquaredExponential</code>: Type of kernel to interpolate (see <code>KernelLabel</code>)</li><li><code>residuals=true</code>: True if you want the problem to return residuals.</li></ul><p>Output:</p><ul><li><code>k</code>: The kernel function</li></ul><p>(if <code>residuals=true</code>)</p><ul><li><code>R</code>: The total residual</li><li><code>R_bd</code>: The boundary condition residual</li><li><code>R_inv</code>: The invariance residual</li><li><code>R_eps</code>: The smoothness residual</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/KernelLabel.jl#L190-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_energies" href="#SymplecticMapTools.get_energies"><code>SymplecticMapTools.get_energies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_energies(k::KernelLabel; W = 0. * I)</code></pre><p>Get the relevant energies of a kernel label <code>k</code> with boundary weighting matrix <code>W</code>.</p><p>Output energies:</p><ul><li><code>EK = ‖c‖²_k</code> is the smoothing kernel norm</li><li><code>EInv = ‖GKc‖²</code> is a norm penalizing invariance</li><li><code>Ebd = ‖Kc‖²_W</code> is a norm penalizing boundary violation</li><li><code>EL2 = ‖Kc‖²</code> is the ℓ² norm of the points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/KernelLabel.jl#L285-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.kernel_birkhoff" href="#SymplecticMapTools.kernel_birkhoff"><code>SymplecticMapTools.kernel_birkhoff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kernel_birkhoff(xs::AbstractArray, fs::AbstractVector, ϵ::Number, μ::Number;
                σ::Number=0., kernel::Symbol=:SquaredExponential,
                boundary_points::AbstractVector = [])</code></pre><p>This function is mostly deprecated. The solutions to the infinitely discretized limit of this problem (the Birkhoff average) don&#39;t live in the native space. So, the results can be odd, hard to interpret, and wiggly. Use at your own risk.</p><p>Find the &quot;Birkhoff average&quot; of a function using the kernel approach. Solves the least-squares problem<br/>&gt; <code>min_c μ⁻¹(‖GKc‖² + ‖Kc‖²_bd) + ϵ‖c‖²_k + ‖Kc - f‖²</code><br/>where</p><ul><li><code>‖GKc‖²</code> is a norm penalizing invariance</li><li><code>‖c‖²_k</code> is the smoothing kernel norm</li><li><code>‖Kc - f‖²</code> is a least-squares fit norm</li><li><code>‖Kc‖²_bd</code> is a norm penalizing boundary violation</li></ul><p>Arguments:</p><ul><li><code>xs</code>: interpolation points of size d × 2N, where xs[:, N+1:2N] = F.(xs[:, 1:N])</li><li><code>fs</code>: function values at points of size N</li><li><code>ϵ</code>: Amount of regularization (can be set to zero)</li><li><code>μ</code>: Weighting of invariance penalization to fit (should be small, e.g. 1e-6)</li><li><code>σ</code>: Scale of the problem</li><li><code>kernel</code>: Type of kernel to interpolate (see <code>KernelLabel</code>)</li><li><code>boundary_points</code>: A list of indices of points on the boundary</li></ul><p>Output:</p><ul><li><code>k</code>: A KernelLabel object</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/LabelFunction/KernelLabel.jl#L316-L345">source</a></section></article><h2 id="Continued-Fractions"><a class="docs-heading-anchor" href="#Continued-Fractions">Continued Fractions</a><a id="Continued-Fractions-1"></a><a class="docs-heading-anchor-permalink" href="#Continued-Fractions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.ContFrac" href="#SymplecticMapTools.ContFrac"><code>SymplecticMapTools.ContFrac</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContFrac(a::AbstractArray)</code></pre><p>A continued fraction in (0,1]. The member <code>a</code> is a vector of the continued fraction coefficients so that ω = 1/(a[1] + 1/(a[2] + ...))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/ContinuedFractions.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.big_cont_frac_eval" href="#SymplecticMapTools.big_cont_frac_eval"><code>SymplecticMapTools.big_cont_frac_eval</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">big_cont_frac_eval(c::ContFrac)</code></pre><p>Find a high precision representation of the continued fraction as a <code>BigFloat</code>. To set the precision, use <code>precision</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/ContinuedFractions.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.evaluate-Tuple{ContFrac}" href="#SymplecticMapTools.evaluate-Tuple{ContFrac}"><code>SymplecticMapTools.evaluate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate(c::ContFrac)</code></pre><p>Find a floating point representation of the continued fraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/ContinuedFractions.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.partial_frac" href="#SymplecticMapTools.partial_frac"><code>SymplecticMapTools.partial_frac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partial_frac(c::ContFrac, n::Integer)</code></pre><p>Find the <code>n</code>th convergent of the continued fraction <code>c</code> as a rational number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/ContinuedFractions.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.denoms" href="#SymplecticMapTools.denoms"><code>SymplecticMapTools.denoms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">denoms(c::ContFrac)</code></pre><p>Return a list of the denominators of the continued fractions of <code>c</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/ContinuedFractions.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.big_partial_frac" href="#SymplecticMapTools.big_partial_frac"><code>SymplecticMapTools.big_partial_frac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">big_partial_frac(c::ContFrac, n::Integer)</code></pre><p>Find the <code>n</code>th convergent of the continued fraction <code>c</code> as a rational number as  <code>BigInt</code>s. Set the precision with <code>precision</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/ContinuedFractions.jl#L111-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.big_denoms" href="#SymplecticMapTools.big_denoms"><code>SymplecticMapTools.big_denoms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">big_denoms(c::ContFrac)</code></pre><p>Return a list of the denominators of the continued fractions of <code>c</code> as <code>BigInt</code>s. Set the precision with <code>precision</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/ContinuedFractions.jl#L128-L133">source</a></section></article><h2 id="Birkhoff-Extrapolation"><a class="docs-heading-anchor" href="#Birkhoff-Extrapolation">Birkhoff Extrapolation</a><a id="Birkhoff-Extrapolation-1"></a><a class="docs-heading-anchor-permalink" href="#Birkhoff-Extrapolation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.vector_mpe_backslash" href="#SymplecticMapTools.vector_mpe_backslash"><code>SymplecticMapTools.vector_mpe_backslash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_mpe_backslash(x::AbstractArray, K::Integer)</code></pre><p>Applies Birkhoff vector MPE to a sequence <code>x_n = x[:, n]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/MPE.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.vector_mpe_iterative" href="#SymplecticMapTools.vector_mpe_iterative"><code>SymplecticMapTools.vector_mpe_iterative</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_mpe_backslash(x::AbstractArray, K::Integer)</code></pre><p>Applies Birkhoff vector MPE to a sequence <code>x_n = x[:, n]</code> using the LSQR algorithm. This currently does not have preconditioning, and therefore is less accurate than <code>vector_mpe_backslash</code>.</p><p>Arguments:</p><ul><li><code>x</code>: The sequence</li><li><code>K</code>: The number of unknowns in the filter</li><li><code>c0</code>: The initial guess of</li><li><code>atol</code>, <code>btol</code>: Tolerances. See <code>IterativeSolvers.lsqr!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/MPE.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.wba_weight" href="#SymplecticMapTools.wba_weight"><code>SymplecticMapTools.wba_weight</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">wba_weight(d, N)</code></pre><p>Weights used in the weighted Birkhoff average, returned as a diagonal matrix. Returns as <code>Diagonal([w_1, ..., w_1, ..., w_N, ..., w_N])</code>, where each coefficient is repeated <code>d</code> times (this is used for vector MPE and RRE as a least-squares weighting)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.weighted_birkhoff_average" href="#SymplecticMapTools.weighted_birkhoff_average"><code>SymplecticMapTools.weighted_birkhoff_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">weighted_birkhoff_average(hs::AbstractMatrix)</code></pre><p>Finds a weighted Birkhoff average of a sequence of vector observations. The array input is assumed to be of size d × N, where the average is performed over the second index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L20-L26">source</a></section><section><div><pre><code class="nohighlight hljs">weighted_birkhoff_average(hs::AbstractVector)</code></pre><p>Finds a weighted Birkhoff average of a sequence of scalar observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.doubling_birkhoff_average" href="#SymplecticMapTools.doubling_birkhoff_average"><code>SymplecticMapTools.doubling_birkhoff_average</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">doubling_birkhoff_average(h::Function, F::Function, x0::AbstractVector;
                          tol::Number = 1e-10, T_init::Integer=10,
                          T_max::Integer=320)</code></pre><p>Find the weighted Birkhoff ergodic average of an observable function <code>h</code> over a trajectory of the map <code>F</code> adaptively.</p><p>Arguments:</p><ul><li><code>h</code>: A function from Rᵈ to Rⁿ, where d is the dimension of the state space and n is the dimension of the observation</li><li><code>F</code>: The (symplectic) map: a function from Rᵈ to Rᵈ</li><li><code>x0</code>: The initial point of the trajectory in Rᵈ</li><li><code>tol</code>: The tolerance by which convergence is judged. If the average does not change by more than <code>tol</code> over a doubling, the function returns</li><li><code>T_init</code>: The initial length of the trajectory considered</li><li><code>T_max</code>: The maximum trajectory length considered</li></ul><p>Output:</p><ul><li><code>ave</code>: The average of <code>h</code> over the trajectory</li><li><code>xs</code>: The trajectory</li><li><code>hs</code>: The value of <code>h</code> on the trajectory</li><li><code>conv_flag</code>: <code>true</code> iff the averages converged</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L44-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.birkhoff_extrapolation" href="#SymplecticMapTools.birkhoff_extrapolation"><code>SymplecticMapTools.birkhoff_extrapolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">birkhoff_extrapolation(h::Function, F::Function, x0::AbstractVector,
                       N::Integer, K::Integer; iterative::Bool=true,
                       x_prev::Union{AbstractArray,Nothing}=nothing)</code></pre><p>As input, takes an initial point <code>x0</code>, a symplectic map <code>F</code>, and an observable <code>h</code> (can choose the identity as a default <code>h = (x)-&gt;x</code>). Then, the method</p><ol><li>Computes a time series xs[:,n+1] = Fⁿ(x0)</li><li>Computes observable series hs[:,n] = h(xs[:,n])</li><li>Performs sequence extrapolation (RRE or MPE) on hs to obtain a model <code>c</code> of  degree <code>K</code>, the extrapolated value applied to each window, and a residual</li><li>Returns as <code>c, sums, resid, xs, hs[, history]</code> where <code>history</code> is a  diagnostic from the iterative solver that only returns when <code>iterative=true</code></li></ol><p>Use <code>x_prev</code> if you already know part of the sequence, but do not know the whole thing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L120-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.adaptive_birkhoff_extrapolation" href="#SymplecticMapTools.adaptive_birkhoff_extrapolation"><code>SymplecticMapTools.adaptive_birkhoff_extrapolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">adaptive_birkhoff_extrapolation(h::Function, F::Function,
                x0::AbstractVector; rtol::Number=1e-12, Kinit = 20,
                Kmax = 100, Kstride=20, iterative::Bool=true,
                Nfactor::Integer=1)</code></pre><p>Adaptively applies <code>birkhoff_extrapolation</code> to find a good enough filter length <code>K</code>, where &quot;good enough&quot; is defined by the <code>rtol</code> optional argument.</p><p>Arguments:</p><ul><li><code>h</code>: The observable function (can choose the identity as a default <code>h = (x)-&gt;x</code>)</li><li><code>F</code>: The symplectic map</li><li><code>x0</code>: The initial point of the trajectory</li><li><code>rtol</code>: Required tolerance for convergence (inexact maps often require a looser tolerance)</li><li><code>Kinit</code>: The length of the initial filter</li><li><code>Kmax</code>: The maximum allowed filter size</li><li><code>Kstride</code>: The amount <code>K</code> increases between applications of            <code>birkhoff_extrapolation</code></li><li><code>iterative</code>: Whether to use an iterative method to solve the Hankel system              in the extrapolation step</li><li><code>Nfactor</code>: How rectangular the extrapolation algorithm is. Must be &gt;=1.</li></ul><p>Outputs:</p><ul><li><code>c</code>: Linear model / filter</li><li><code>sums</code>: The extrapolated value applied to each window</li><li><code>resid</code>: The least squares residual</li><li><code>xs</code>: A time series <code>x[:,n] = Fⁿ(x[:,0])</code></li><li><code>hs</code>: The observations <code>h[:,n] = h(x[:,n])</code></li><li><code>rnorm</code>: The norm of resid</li><li><code>K</code>: The final degree of the filter</li><li><code>history</code>: Returned if <code>iterative=true</code>. The history of the final LSQR iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L178-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.sum_stats" href="#SymplecticMapTools.sum_stats"><code>SymplecticMapTools.sum_stats</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sum_stats(sums)</code></pre><p>Given a sequence of sums applied to a filter (an output of invariant circle extrapolation), find the average and standard deviation of the sums. Can be used as a measure of how &quot;good&quot; the filter is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L238-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_sum_ave" href="#SymplecticMapTools.get_sum_ave"><code>SymplecticMapTools.get_sum_ave</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_sum_ave(hs, c)</code></pre><p>Given a signal <code>hs</code> (of size either d×N or N×1) and a filter <code>c</code> of size M×1, compute the average of the M-N windows of the filter applied to the signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L260-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.get_circle_info" href="#SymplecticMapTools.get_circle_info"><code>SymplecticMapTools.get_circle_info</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_circle_info(hs::AbstractArray, c::AbstractArray; rattol::Number=1e-8,
                ratcutoff::Number=1e-4, max_island_d::Integer=30)</code></pre><p>Get a Fourier representation of an invariant circle from the observations <code>hs</code> and the learned filter <code>c</code> (see <code>adaptive_invariant_circle_model</code> and <code>invariant_circle_model</code> to find the filter). See <code>get_circle_residual</code> for an a posteriori validation of the circle.</p><p>Optional Arguments:</p><ul><li><code>rattol</code>: Roots are judged to be rational if |ω-m/n|&lt;rattol</li><li><code>ratcutoff</code>: Relative prominence needed by a linear mode to qualify as &quot;important&quot; for deciding whether the sequence is an island</li><li><code>max_island_d</code>: Maximum denominator considered for islands.</li></ul><p>Output:</p><ul><li><code>z</code>: An invariant circle of type <code>FourierCircle</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Birkhoff/BirkhoffAveraging.jl#L413-L430">source</a></section></article><h2 id="Example-Maps"><a class="docs-heading-anchor" href="#Example-Maps">Example Maps</a><a id="Example-Maps-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Maps" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.standard_map_F" href="#SymplecticMapTools.standard_map_F"><code>SymplecticMapTools.standard_map_F</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standard_map_F(k)</code></pre><p>Returns the Chirikov standard map with parameter <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Examples/StandardMap.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.standard_map_FJ" href="#SymplecticMapTools.standard_map_FJ"><code>SymplecticMapTools.standard_map_FJ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standard_map_FJ(k)</code></pre><p>Returns a function <code>FJ</code> that returns the Chirikov standard map and its derivative (i.e. <code>F, dFdx = FJ(x)</code>) with parameter <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Examples/StandardMap.jl#L19-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.polar_map" href="#SymplecticMapTools.polar_map"><code>SymplecticMapTools.polar_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">polar_map(;z0 = -0.5)</code></pre><p>Returns the polar map <br/>&gt; <code>h:(θ,z)-&gt;((z-z0)cos(2πθ), (z-z0)sin(2πθ))</code><br/>as well as its derivative <code>HJ</code>, its inverse <code>hinv</code>, and its inverse derivative <code>HJinv</code>. Useful for applying extrapolation methods to maps on T×R. Default value of <code>z0</code> is useful for the standard map on T×[0,1] with k=0.7.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/src/Examples/StandardMap.jl#L43-L51">source</a></section></article><h2 id="Plotting-Routines:-Plots"><a class="docs-heading-anchor" href="#Plotting-Routines:-Plots">Plotting Routines: Plots</a><a id="Plotting-Routines:-Plots-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Routines:-Plots" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot-Tuple{InvariantCircle}" href="#RecipesBase.plot-Tuple{InvariantCircle}"><code>RecipesBase.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.plot(z::InvariantCircle; kwargs...)</code></pre><p>Creates a plot of the invariant circle <code>z</code>. See <code>Plots.plot!(z::InvariantCircle)</code> for a list of keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/PlotsUtils.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot!-Tuple{Plots.Plot, InvariantCircle}" href="#RecipesBase.plot!-Tuple{Plots.Plot, InvariantCircle}"><code>RecipesBase.plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.plot(p::Plots.Plot, z::InvariantCircle; kwargs...)</code></pre><p>Plots the invariant circle z on p.</p><p>kwargs:</p><ul><li><code>N::Integer</code>: Number of θ points used to plot each circle</li><li><code>i_circle::Integer</code>: Which period of an island chain to plot. Default value of <code>0</code> plots all circles of an island chain.</li><li><code>label</code>, <code>color</code>, <code>linewidth</code>, <code>linestyle</code>: see Plots.jl</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/PlotsUtils.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.parametric_plot" href="#SymplecticMapTools.parametric_plot"><code>SymplecticMapTools.parametric_plot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parametric_plot(z::InvariantCircle; N::Integer=200, i_circle::Integer=1,
                linewidth=1, linestyle=:solid, label1=&quot;x&quot;, label2=&quot;y&quot;,
                xlabel=&quot;θ&quot;, plot_min_dθs=true, markersize=5)</code></pre><p>Parametric plot of an invariant circle.</p><p>kwargs:</p><ul><li><code>N::Integer</code>: Number of θ points used to plot each circle</li><li><code>i_circle::Integer</code>: Which period of an island chain to plot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/PlotsUtils.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot-Tuple{ConnectingOrbit}" href="#RecipesBase.plot-Tuple{ConnectingOrbit}"><code>RecipesBase.plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.plot(c::ConnectingOrbit; kwargs...)</code></pre><p>Creates a plot of the connecting orbit <code>c</code>. See <code>Plots.plot!(c::ConnectingOrbit)</code> for a list of keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/PlotsUtils.jl#L96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.plot!-Tuple{Plots.Plot, ConnectingOrbit}" href="#RecipesBase.plot!-Tuple{Plots.Plot, ConnectingOrbit}"><code>RecipesBase.plot!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plots.plot!(p::Plots.Plot, c::ConnectingOrbit; kwargs...)</code></pre><p>Creates a plot of the connecting orbit <code>c</code>.</p><p>kwargs:</p><ul><li><code>N::Integer</code>: Number of points used to plot each orbit</li><li><code>i_circle::Integer</code>: Which period of a connecting orbit chain to plot. Default value of <code>0</code> plots all connecting orbits of a island chain.</li><li><code>label</code>, <code>color</code>, <code>linewidth</code>: see Plots.jl</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/PlotsUtils.jl#L117-L127">source</a></section></article><h2 id="Plotting-Routines:-CairoMakie"><a class="docs-heading-anchor" href="#Plotting-Routines:-CairoMakie">Plotting Routines: CairoMakie</a><a id="Plotting-Routines:-CairoMakie-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting-Routines:-CairoMakie" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MakieCore.lines!-Tuple{Any, InvariantCircle}" href="#MakieCore.lines!-Tuple{Any, InvariantCircle}"><code>MakieCore.lines!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>CairoMakie.lines!(ax, z::InvariantCircle; N::Integer=100, color=nothing,                      i_circle::Integer=0, linewidth=1)</p><p>Plot the invariant circle <code>z</code> on the CairoMakie axis <code>ax</code>.</p><p>Arguments:</p><ul><li><code>ax</code>: CairoMakie Axis object</li><li><code>z</code>: The circle in R² to be plotted</li><li><code>N</code>: Number of points to plot</li><li><code>i_circle</code>: Which invariant circle of an island to plot. If 0, plot all</li><li><code>color</code>, <code>linewidth</code>: see <code>CairoMakie.lines!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/CairoMakieUtils.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.lines_periodic!-Tuple{Any, InvariantCircle, Function}" href="#SymplecticMapTools.lines_periodic!-Tuple{Any, InvariantCircle, Function}"><code>SymplecticMapTools.lines_periodic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lines_periodic!(ax, z::InvariantCircle, hinv::Function; N::Integer=100,
                color=nothing, i_circle::Integer=0, linewidth=1)</code></pre><p>Useful for plotting with invariant circles on the torus. I.e., if F : T×R→T×R, and one finds an invariant circle of z(θ+τ) = (h∘F)(z(θ)) where h : T×R→R², this plots h⁻¹∘z, the original invariant circle.</p><p>Arguments:</p><ul><li><code>ax</code>: CairoMakie Axis object</li><li><code>z</code>: The circle in R² to be plotted</li><li><code>hinv</code>: The map to the torus by the real numbers h⁻¹ : R²→T×R</li><li><code>N</code>: Number of points to plot</li><li><code>i_circle</code>: Which invariant circle of an island to plot. If 0, plot all</li><li><code>color</code>, <code>linewidth</code>, <code>label</code>: see <code>CairoMakie.lines!</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/CairoMakieUtils.jl#L33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.plot_on_grid-Tuple{AbstractVector, AbstractVector, KernelLabel}" href="#SymplecticMapTools.plot_on_grid-Tuple{AbstractVector, AbstractVector, KernelLabel}"><code>SymplecticMapTools.plot_on_grid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plot_on_grid(x::AbstractVector, y::AbstractVector, k::KernelLabel;
             kwargs...)</code></pre><p>Create a filled contour plot of the kernel label <code>k</code> on the <code>x</code> × <code>y</code> grid.</p><p>kwargs:</p><ul><li><code>balance=true</code>: If true, makes the maximum value of the color scale equal to the minimum</li><li><code>resolution</code>, <code>fontsize</code>: See <code>CairoMakie.Figure</code></li><li><code>xlabel</code>, <code>ylabel</code>, <code>title</code>: See <code>CairoMakie.Axis</code></li><li><code>levels</code>, <code>linewidth</code>: See <code>CairoMakie.contour!</code></li><li><code>clabel</code>: See <code>CairoMakie.Colorbar</code></li></ul><p>Output:</p><ul><li><code>f</code>: The CairoMakie Figure</li><li><code>f_grid</code>: The data used to make the figure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/CairoMakieUtils.jl#L86-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SymplecticMapTools.poincare_plot-Tuple{AbstractVector, AbstractVector, Function, Integer, Integer}" href="#SymplecticMapTools.poincare_plot-Tuple{AbstractVector, AbstractVector, Function, Integer, Integer}"><code>SymplecticMapTools.poincare_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">poincare_plot(xb::AbstractVector, yb::AbstractVector, F::Function,
              Ninit::Integer, Niter::Integer; resolution=(800, 800),
              fontsize=25, xlabel=&quot;x&quot;, ylabel=&quot;y&quot;, xlims = nothing,
              ylims=nothing, markersize=3, title=&quot;Poincare Plot&quot;)</code></pre><p>Create a Poincare plot of a 2D map <code>F</code> in a rectangular region <code>xb</code>×<code>yb</code>. The Poincare plot uses <code>Ninit</code> trajectories of length <code>Niter</code>.</p><p>Output:</p><ul><li><code>f</code>: The figure</li><li><code>xs</code>: The trajectories used to make the figure</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/maxeruth/SymplecticMapTools.jl/blob/ee68bd8742087fb7b5e6c4380f528e81ea2789c2/ext/CairoMakieUtils.jl#L141-L153">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../examples/kernel/kernel/">« Approximately Invariant Kernel Functions</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 21 August 2023 16:30">Monday 21 August 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
